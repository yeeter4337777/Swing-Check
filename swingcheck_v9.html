<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SwingCheck v1765371417 - - Golf Swing Analyzer</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Fraunces:wght@700;800&display=swap" rel="stylesheet">
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    
    <style>
        :root {
            --bg-primary: #0a120a;
            --bg-secondary: #141f14;
            --bg-card: #1a2a1a;
            --accent-green: #4ade80;
            --accent-lime: #a3e635;
            --accent-emerald: #34d399;
            --text-primary: #f0fdf4;
            --text-secondary: #86efac;
            --text-muted: #6b7c6b;
            --border-color: #2d4a2d;
            --error-red: #f87171;
            --warning-amber: #fbbf24;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Gradient background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60vh;
            background: radial-gradient(ellipse at 50% 0%, rgba(74, 222, 128, 0.08) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        /* Header */
        .header {
            text-align: center;
            padding: 30px 0 40px;
        }
        
        .logo {
            font-family: 'Fraunces', serif;
            font-size: 2.2rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-lime) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
        }
        
        .tagline {
            color: var(--text-muted);
            font-size: 0.95rem;
            margin-top: 8px;
        }
        
        /* Camera Angle Selection */
        .section {
            margin-bottom: 28px;
        }
        
        .section-label {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        
        .angle-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .angle-option {
            position: relative;
        }
        
        .angle-option input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }
        
        .angle-option label {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 16px;
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .angle-option input:checked + label {
            border-color: var(--accent-green);
            background: rgba(74, 222, 128, 0.08);
        }
        
        .angle-icon {
            width: 48px;
            height: 48px;
            margin-bottom: 10px;
            opacity: 0.7;
        }
        
        .angle-option input:checked + label .angle-icon {
            opacity: 1;
        }
        
        .angle-name {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 4px;
        }
        
        .angle-desc {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-align: center;
        }
        
        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 20px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-secondary);
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: var(--accent-green);
            background: rgba(74, 222, 128, 0.05);
        }
        
        .upload-icon {
            width: 56px;
            height: 56px;
            margin: 0 auto 16px;
            opacity: 0.6;
        }
        
        .upload-text {
            font-weight: 600;
            font-size: 1.05rem;
            margin-bottom: 6px;
        }
        
        .upload-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        #videoInput {
            display: none;
        }
        
        /* Video Preview */
        .video-container {
            display: none;
            position: relative;
            border-radius: 20px;
            overflow: hidden;
            background: var(--bg-card);
            margin-bottom: 20px;
        }
        
        .video-container.visible {
            display: block;
        }
        
        #videoPreview {
            width: 100%;
            display: block;
            border-radius: 20px;
        }
        
        #canvasOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .video-controls {
            display: flex;
            gap: 10px;
            margin-top: 12px;
        }
        
        /* Buttons */
        .btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-family: 'DM Sans', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-emerald) 100%);
            color: var(--bg-primary);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(74, 222, 128, 0.3);
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--bg-secondary);
        }
        
        /* Progress */
        .progress-container {
            display: none;
            margin: 20px 0;
        }
        
        .progress-container.visible {
            display: block;
        }
        
        .progress-bar {
            height: 6px;
            background: var(--bg-card);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-lime));
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 10px;
        }
        
        /* Results Section */
        .results-section {
            display: none;
        }
        
        .results-section.visible {
            display: block;
        }
        
        /* Key Frames Grid */
        .keyframes-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 28px;
        }
        
        .keyframe-card {
            background: var(--bg-card);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        
        .keyframe-canvas {
            width: 100%;
            aspect-ratio: 3/4;
            display: block;
            background: var(--bg-secondary);
        }
        
        .keyframe-label {
            padding: 10px 12px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            border-top: 1px solid var(--border-color);
        }
        
        /* Impact Frame Adjustment */
        .impact-adjust {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            padding: 8px 8px 12px;
            background: var(--bg-secondary);
        }
        
        .adjust-btn {
            width: 36px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .adjust-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        
        .adjust-btn:active {
            background: var(--accent-green);
            color: #000;
            transform: scale(0.95);
        }
        
        .adjust-offset {
            min-width: 32px;
            text-align: center;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-green);
        }
        
        /* Stats Summary Section */
        .stats-summary {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }
        
        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .stats-title {
            font-family: 'Fraunces', serif;
            font-size: 1.2rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0;
        }
        
        .swing-score {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, var(--accent-green), var(--accent-lime));
            border-radius: 12px;
            padding: 8px 16px;
            min-width: 70px;
        }
        
        .swing-score .score-value {
            font-family: 'Fraunces', serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--bg-primary);
            line-height: 1;
        }
        
        .swing-score .score-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--bg-primary);
            opacity: 0.8;
            text-transform: uppercase;
        }
        
        .swing-score.score-great {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-lime));
        }
        
        .swing-score.score-good {
            background: linear-gradient(135deg, #22c55e, #84cc16);
        }
        
        .swing-score.score-fair {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
        }
        
        .swing-score.score-poor {
            background: linear-gradient(135deg, #ef4444, #f97316);
        }
        
        .swing-score .club-indicator {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--bg-primary);
            opacity: 0.7;
            text-transform: uppercase;
            margin-top: 2px;
            padding: 1px 6px;
            background: rgba(0,0,0,0.15);
            border-radius: 4px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .stat-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stat-card.stat-good {
            border-left: 3px solid var(--accent-green);
        }
        
        .stat-card.stat-warning {
            border-left: 3px solid var(--warning-amber);
        }
        
        .stat-card.stat-poor {
            border-left: 3px solid #ef4444;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: baseline;
            gap: 4px;
        }
        
        .stat-unit {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-muted);
        }
        
        .stat-range {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .view-more-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            padding: 12px;
            margin-top: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .view-more-btn:hover {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .view-more-btn.expanded svg {
            transform: rotate(180deg);
        }
        
        .view-more-btn svg {
            transition: transform 0.2s ease;
        }
        
        .advanced-stats {
            display: none;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }
        
        .advanced-stats.visible {
            display: block;
        }
        
        .stats-category {
            margin-bottom: 16px;
        }
        
        .stats-category:last-child {
            margin-bottom: 0;
        }
        
        .stats-category-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0 0 10px 0;
        }
        
        /* Tips Section */
        .tips-container {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 24px;
            border: 1px solid var(--border-color);
        }
        
        .tips-header {
            font-family: 'Fraunces', serif;
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tip-item {
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
            margin-bottom: 12px;
            border-left: 3px solid var(--accent-green);
        }
        
        .tip-item:last-child {
            margin-bottom: 0;
        }
        
        .tip-item.warning {
            border-left-color: var(--warning-amber);
        }
        
        .tip-item.error {
            border-left-color: var(--error-red);
        }
        
        .tip-category {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-green);
            margin-bottom: 6px;
        }
        
        .tip-item.warning .tip-category {
            color: var(--warning-amber);
        }
        
        .tip-item.error .tip-category {
            color: var(--error-red);
        }
        
        .tip-text {
            font-size: 0.95rem;
            line-height: 1.5;
            color: var(--text-primary);
        }
        
        .tip-detail {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 8px;
            line-height: 1.4;
        }
        
        /* Measurements */
        .measurements {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }
        
        .measurements-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .measurement-item {
            text-align: center;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
        }
        
        .measurement-value {
            font-family: 'Fraunces', serif;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--accent-lime);
        }
        
        .measurement-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 4px;
        }
        
        /* Tempo Section */
        .tempo-section {
            margin-top: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
        }
        
        .tempo-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .tempo-title {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .tempo-ratio {
            font-family: 'Fraunces', serif;
            font-size: 1.3rem;
            font-weight: 700;
        }
        
        .tempo-rating {
            font-family: 'DM Sans', sans-serif;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 6px;
        }
        
        .tempo-great { color: var(--accent-green); }
        .tempo-warning { color: #f59e0b; }
        .tempo-poor { color: #ef4444; }
        
        .tempo-bar-container {
            margin-bottom: 12px;
        }
        
        .tempo-bar {
            display: flex;
            height: 32px;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .tempo-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            transition: width 0.3s ease;
        }
        
        .tempo-segment-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--bg-primary);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .tempo-backswing {
            background: linear-gradient(135deg, #3b82f6, #60a5fa);
        }
        
        .tempo-downswing {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-lime));
        }
        
        .tempo-followthrough {
            background: linear-gradient(135deg, #8b5cf6, #a78bfa);
        }
        
        .tempo-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        .tempo-labels span {
            flex: 1;
            text-align: center;
        }
        
        .tempo-labels span:first-child { text-align: left; }
        .tempo-labels span:last-child { text-align: right; }
        
        .tempo-advice {
            font-size: 0.85rem;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .tempo-advice.tempo-great {
            background: rgba(74, 222, 128, 0.1);
            border-left: 3px solid var(--accent-green);
        }
        
        .tempo-advice.tempo-warning {
            background: rgba(245, 158, 11, 0.1);
            border-left: 3px solid #f59e0b;
        }
        
        .tempo-advice.tempo-poor {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
        }
        
        .tempo-total {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: center;
        }
        
        .tempo-total strong {
            color: var(--text-primary);
        }
        
        /* Drawing Tools Section */
        .drawing-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }
        
        .drawing-section .section-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .btn-icon {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-icon:hover {
            background: var(--accent-green);
            color: var(--bg-primary);
            border-color: var(--accent-green);
        }
        
        /* Drawing Modal - Simple Fullscreen Overlay */
        .drawing-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
        }
        
        .drawing-modal.visible {
            display: block;
        }
        
        /* Canvas Container - Centered */
        .drawing-canvas-container {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            touch-action: none;
        }
        
        /* Wrapper to hold both canvases stacked */
        .drawing-canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .drawing-canvas-container canvas {
            display: block;
        }
        
        #drawingCanvasBg {
            position: relative;
            z-index: 1;
        }
        
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            cursor: crosshair;
        }
        
        /* Close Button */
        .drawing-close-btn {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 12px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1010;
        }
        
        /* Tools Dropdown */
        .drawing-tools-dropdown {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 1010;
        }
        
        .tools-toggle-btn {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 12px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .tools-toggle-btn.active {
            background: var(--accent-green);
            color: #000;
        }
        
        .tools-menu {
            display: none;
            position: absolute;
            top: 52px;
            right: 0;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 12px;
            min-width: 200px;
        }
        
        .tools-menu.visible {
            display: block;
        }
        
        .tools-section {
            margin-bottom: 12px;
        }
        
        .tools-section:last-child {
            margin-bottom: 0;
        }
        
        .tools-section-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .tools-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .tool-btn {
            width: 42px;
            height: 42px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tool-btn.active {
            background: var(--accent-green);
            color: #000;
        }
        
        .color-btn {
            width: 32px;
            height: 32px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .color-btn.active {
            border-color: #fff;
            transform: scale(1.1);
        }
        
        .action-btn {
            width: 42px;
            height: 42px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .action-btn.save {
            background: var(--accent-green);
            color: #000;
        }
        
        /* Bottom Controls */
        .drawing-zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 12px;
            z-index: 1010;
        }
        
        .zoom-btn {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-level {
            color: #fff;
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 45px;
            text-align: center;
        }
        
        .drawing-frame-nav {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 12px;
            z-index: 1010;
        }
        
        .btn-nav {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .drawing-frame-selector {
            display: flex;
            gap: 4px;
        }
        
        .frame-btn {
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .frame-btn.active {
            background: var(--accent-green);
            color: #000;
        }
        
        .current-tool-indicator {
            position: absolute;
            bottom: 20px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 12px;
            z-index: 1010;
        }
        
        .current-tool-label {
            color: #fff;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .current-color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        /* Hide unused */
        .drawing-modal-content,
        .drawing-header,
        .drawing-overlay-controls,
        .drawing-toolbar,
        .btn-close,
        .tool-group {
            display: none;
        }

        /* Reset Button */
        .reset-section {
            margin-top: 28px;
            text-align: center;
        }
        
        /* Loading Spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.4s ease forwards;
        }
        
        /* No Tips State */
        .no-issues {
            text-align: center;
            padding: 20px;
        }
        
        .no-issues-icon {
            font-size: 3rem;
            margin-bottom: 12px;
        }
        
        .no-issues-text {
            color: var(--accent-green);
            font-weight: 600;
        }
        
        /* Tips Summary */
        .tips-summary {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        
        .tips-summary span {
            font-size: 0.75rem;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 12px;
        }
        
        .summary-critical {
            background: rgba(248, 113, 113, 0.2);
            color: var(--error-red);
        }
        
        .summary-warning {
            background: rgba(251, 191, 36, 0.2);
            color: var(--warning-amber);
        }
        
        .summary-info {
            background: rgba(96, 165, 250, 0.2);
            color: var(--accent-blue);
        }
        
        /* Tips Section Headers */
        .tips-section-header {
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 20px 0 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tips-section-header:first-child {
            margin-top: 0;
        }
        
        .error-header {
            color: var(--error-red);
            border-bottom-color: rgba(248, 113, 113, 0.3);
        }
        
        .warning-header {
            color: var(--warning-amber);
            border-bottom-color: rgba(251, 191, 36, 0.3);
        }
        
        .info-header {
            color: var(--accent-blue);
            border-bottom-color: rgba(96, 165, 250, 0.3);
        }
        
        /* Enhanced Tip Items */
        .tip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .tip-badge {
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            padding: 3px 8px;
            border-radius: 8px;
        }
        
        .error-badge {
            background: var(--error-red);
            color: white;
        }
        
        /* Drill styling */
        .tip-drill {
            margin-top: 12px;
            padding: 12px;
            background: rgba(74, 222, 128, 0.08);
            border-radius: 8px;
            border-left: 3px solid var(--accent-green);
        }
        
        .drill-header {
            margin-bottom: 6px;
        }
        
        .drill-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent-green);
        }
        
        .drill-text {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
        }
        
        .drill-video-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: #ff0000;
            color: white;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.2s ease;
        }
        
        .drill-video-link:hover {
            background: #cc0000;
            transform: translateY(-1px);
        }
        
        .drill-video-link svg {
            flex-shrink: 0;
        }
        
        /* Success tip styling */
        .tip-item.success {
            border-left-color: var(--accent-green);
            background: rgba(74, 222, 128, 0.05);
        }
        
        .tip-item.success .tip-category {
            color: var(--accent-green);
        }
        
        /* Reference Lines Legend */
        .reference-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
            padding: 12px;
            background: var(--bg-card);
            border-radius: 10px;
            font-size: 0.75rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }
        
        .legend-line.spine { background: rgba(251, 191, 36, 0.8); }
        .legend-line.head { background: rgba(96, 165, 250, 0.7); }
        .legend-line.shoulders { background: rgba(74, 222, 128, 0.6); }
        .legend-line.hips { background: rgba(248, 113, 113, 0.6); }
        .legend-line.swing-plane { background: rgba(168, 85, 247, 0.7); }
        
        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid;
        }
        
        .legend-circle.ball {
            border-color: rgba(255, 255, 255, 0.6);
            background: transparent;
        }
        
        .legend-text {
            color: var(--text-muted);
        }
        
        /* Replay Player Styles */
        .replay-section {
            margin-top: 24px;
            margin-bottom: 24px;
        }
        
        .replay-container {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 16px;
            border: 1px solid var(--border-color);
        }
        
        .replay-canvas {
            width: 100%;
            max-width: 400px;
            height: auto;
            aspect-ratio: 3/4;
            background: var(--bg-secondary);
            border-radius: 12px;
            display: block;
            margin: 0 auto 16px;
        }
        
        .replay-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .replay-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .replay-btn:hover {
            background: var(--border-color);
            border-color: var(--accent-green);
        }
        
        .replay-btn-main {
            width: 56px;
            height: 56px;
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-primary);
        }
        
        .replay-btn-main:hover {
            background: var(--accent-lime);
            border-color: var(--accent-lime);
        }
        
        .replay-scrubber {
            margin-bottom: 12px;
        }
        
        .replay-scrubber input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-secondary);
            outline: none;
            -webkit-appearance: none;
            margin-bottom: 8px;
        }
        
        .replay-scrubber input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-green);
            cursor: pointer;
            border: 2px solid var(--bg-primary);
        }
        
        .replay-scrubber input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-green);
            cursor: pointer;
            border: 2px solid var(--bg-primary);
        }
        
        .replay-frame-info {
            text-align: center;
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .replay-speed {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .replay-speed select {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 4px 8px;
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .replay-speed select:focus {
            outline: none;
            border-color: var(--accent-green);
        }
        
        /* Ghost Mode Controls */
        .ghost-mode-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }
        
        .ghost-toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .ghost-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .ghost-toggle input {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-green);
        }
        
        .ghost-toggle-label {
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .ghost-pro-select {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.8rem;
        }
        
        .ghost-pro-select:disabled {
            opacity: 0.5;
        }
        
        .ghost-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.75rem;
        }
        
        .legend-you {
            color: #4ade80;
        }
        
        .legend-pro {
            color: #f59e0b;
        }
        
        /* Toggle Switch */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 12px;
        }
        
        .toggle-label {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .toggle-desc {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        /* Handedness Selector */
        .handedness-selector {
            display: flex;
            gap: 4px;
            background: var(--bg-secondary);
            padding: 3px;
            border-radius: 8px;
        }
        
        .hand-btn {
            padding: 6px 12px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 0.8rem;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .hand-btn.active {
            background: var(--accent-green);
            color: var(--bg-primary);
        }
        
        .hand-btn:hover:not(.active) {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        /* Club Selector */
        .club-selector {
            display: flex;
            gap: 12px;
        }
        
        .club-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px 12px;
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .club-btn .club-icon {
            width: 32px;
            height: 32px;
        }
        
        .club-btn.active {
            border-color: var(--accent-green);
            background: rgba(74, 222, 128, 0.1);
            color: var(--accent-green);
        }
        
        .club-btn:hover:not(.active) {
            border-color: var(--text-muted);
            color: var(--text-primary);
        }
        
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
            flex-shrink: 0;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-secondary);
            border-radius: 28px;
            transition: 0.3s;
            border: 2px solid var(--border-color);
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background: var(--text-muted);
            border-radius: 50%;
            transition: 0.3s;
        }
        
        .toggle-switch input:checked + .toggle-slider {
            background: var(--accent-green);
            border-color: var(--accent-green);
        }
        
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
            background: var(--bg-primary);
        }
        
        /* Mode Tabs for Analyze/Compare */
        .mode-tabs {
            display: flex;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 20px;
        }
        
        .mode-tab {
            flex: 1;
            padding: 12px 16px;
            text-align: center;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .mode-tab.active {
            background: var(--bg-card);
            color: var(--accent-green);
        }
        
        .mode-content {
            display: none;
        }
        
        .mode-content.active {
            display: block;
        }
        
        /* Comparison Mode */
        .compare-uploads {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .compare-upload-box {
            border: 2px dashed var(--border-color);
            border-radius: 16px;
            padding: 24px 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-secondary);
            min-height: 140px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .compare-upload-box:hover {
            border-color: var(--accent-green);
            background: rgba(74, 222, 128, 0.05);
        }
        
        .compare-upload-box.has-video {
            border-style: solid;
            border-color: var(--accent-green);
            background: rgba(74, 222, 128, 0.08);
        }
        
        .compare-upload-box .upload-icon {
            width: 36px;
            height: 36px;
            margin-bottom: 8px;
        }
        
        .compare-upload-box .label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        .compare-upload-box .filename {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 4px;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .compare-upload-box .checkmark {
            color: var(--accent-green);
            font-size: 1.5rem;
            margin-bottom: 4px;
        }
        
        /* Comparison Results */
        .comparison-container {
            display: none;
        }
        
        .comparison-container.visible {
            display: block;
        }
        
        .comparison-phase-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            overflow-x: auto;
            padding-bottom: 8px;
        }
        
        .phase-btn {
            padding: 8px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            color: var(--text-muted);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }
        
        .phase-btn.active {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-primary);
        }
        
        .comparison-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .comparison-frame {
            position: relative;
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .comparison-frame canvas {
            width: 100%;
            display: block;
        }
        
        .comparison-frame .frame-label {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.6);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .comparison-frame.swing-a .frame-label {
            color: var(--accent-green);
        }
        
        .comparison-frame.swing-b .frame-label {
            color: var(--accent-blue);
        }
        
        /* Overlay mode toggle */
        .overlay-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .overlay-toggle span {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        /* Comparison metrics */
        .comparison-metrics {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 16px;
            border: 1px solid var(--border-color);
        }
        
        .comparison-metrics h3 {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-secondary);
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-name {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .metric-values {
            display: flex;
            gap: 16px;
        }
        
        .metric-value {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .metric-value.swing-a {
            color: var(--accent-green);
        }
        
        .metric-value.swing-b {
            color: var(--accent-blue);
        }
        
        /* Cropped video preview */
        .cropped-preview {
            display: none;
            margin-top: 16px;
        }
        
        .cropped-preview.visible {
            display: block;
        }
        
        .cropped-preview video {
            width: 100%;
            border-radius: 16px;
            background: var(--bg-card);
        }
        
        .cropped-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 8px;
        }
        
        /* Accent blue for swing B */
        :root {
            --accent-blue: #60a5fa;
        }
        
        /* Pro Selection Grid */
        .pro-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .pro-card {
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 14px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .pro-card:hover {
            border-color: var(--accent-blue);
            background: rgba(96, 165, 250, 0.05);
        }
        
        .pro-card.selected {
            border-color: var(--accent-blue);
            background: rgba(96, 165, 250, 0.1);
        }
        
        .pro-video-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 0.7rem;
            opacity: 0.8;
        }
        
        .pro-avatar {
            font-size: 1.8rem;
            margin-bottom: 6px;
        }
        
        .pro-card .pro-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }
        
        .pro-card .pro-desc {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        /* Pro Video Section */
        .pro-video-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }
        
        .pro-video-container {
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .pro-video-player {
            aspect-ratio: 16/9;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .pro-video-player iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .video-placeholder {
            color: var(--text-muted);
            font-size: 0.85rem;
            text-align: center;
            padding: 20px;
        }
        
        .pro-video-controls {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: var(--bg-tertiary);
        }
        
        .video-select {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        .btn-small {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: var(--accent-blue);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .btn-small:hover {
            background: #4a90e8;
        }
        
        .btn-small:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }
        
        /* User video loaded state */
        .user-video-loaded {
            margin-top: 12px;
        }
        
        .loaded-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid var(--accent-green);
            border-radius: 12px;
        }
        
        .loaded-indicator .checkmark {
            color: var(--accent-green);
            font-size: 1.2rem;
        }
        
        .loaded-indicator .loaded-text {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
        }
        
        /* Comparison header */
        .comparison-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .comparing-to {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .compare-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .pro-name-display {
            font-family: 'Fraunces', serif;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--accent-blue);
        }
        
        /* Pro frame styling */
        .comparison-frame.pro-frame {
            border: 2px solid var(--accent-blue);
        }
        
        .comparison-frame.pro-frame .frame-label {
            color: var(--accent-blue);
        }
        
        /* Pro tips section */
        .pro-tips-section {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            margin-top: 16px;
            border: 1px solid var(--border-color);
        }
        
        .pro-tips-section .tips-header {
            margin-bottom: 16px;
        }
        
        .pro-tip-item {
            padding: 14px;
            background: rgba(96, 165, 250, 0.08);
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 3px solid var(--accent-blue);
        }
        
        .pro-tip-item:last-child {
            margin-bottom: 0;
        }
        
        .pro-tip-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 6px;
            color: var(--text-primary);
        }
        
        .pro-tip-text {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.5;
        }
        
        /* Metric comparison improvements */
        .metric-row .diff {
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
        }
        
        .metric-row .diff.good {
            background: rgba(74, 222, 128, 0.2);
            color: var(--accent-green);
        }
        
        .metric-row .diff.needs-work {
            background: rgba(251, 191, 36, 0.2);
            color: var(--warning-amber);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1 class="logo">SwingCheck</h1>
            <p class="tagline">AI-powered golf swing analysis</p>
        </header>
        
        <!-- Mode Tabs -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="analyze">Analyze</button>
            <button class="mode-tab" data-mode="compare">Compare</button>
        </div>
        
        <!-- ANALYZE MODE -->
        <div class="mode-content active" id="analyzeMode">
        
        <!-- Camera Angle Selection -->
        <section class="section">
            <div class="section-label">Camera Angle</div>
            <div class="angle-selector">
                <div class="angle-option">
                    <input type="radio" name="cameraAngle" id="faceon" value="faceon" checked>
                    <label for="faceon">
                        <svg class="angle-icon" viewBox="0 0 48 48" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="24" cy="12" r="6"/>
                            <path d="M24 18v12M18 24h12M20 30l-4 14M28 30l4 14"/>
                            <rect x="8" y="4" width="32" height="40" rx="2" stroke-dasharray="4 2"/>
                        </svg>
                        <span class="angle-name">Face-On</span>
                        <span class="angle-desc">Camera facing you</span>
                    </label>
                </div>
                <div class="angle-option">
                    <input type="radio" name="cameraAngle" id="dtl" value="dtl">
                    <label for="dtl">
                        <svg class="angle-icon" viewBox="0 0 48 48" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="20" cy="12" r="6"/>
                            <path d="M20 18v12M20 30l-2 14M20 30l6 12"/>
                            <path d="M20 24l10-6" stroke-linecap="round"/>
                            <rect x="8" y="4" width="32" height="40" rx="2" stroke-dasharray="4 2"/>
                        </svg>
                        <span class="angle-name">Down-the-Line</span>
                        <span class="angle-desc">Camera behind you</span>
                    </label>
                </div>
            </div>
        </section>
        
        <!-- Club Selection -->
        <section class="section">
            <div class="section-label">Club Type</div>
            <div class="club-selector">
                <button class="club-btn active" data-club="driver" id="driverBtn">
                    <svg class="club-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2L12 18"/>
                        <ellipse cx="12" cy="20" rx="6" ry="3"/>
                    </svg>
                    <span>Driver</span>
                </button>
                <button class="club-btn" data-club="iron" id="ironBtn">
                    <svg class="club-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2L12 16"/>
                        <path d="M8 18L16 18L14 22L10 22Z" fill="currentColor"/>
                    </svg>
                    <span>Iron</span>
                </button>
            </div>
        </section>
        
        <!-- Auto-Crop Toggle -->
        <div class="toggle-row">
            <div>
                <div class="toggle-label">Auto-Crop & Center</div>
                <div class="toggle-desc">Automatically frame the golfer</div>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="autoCropToggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <!-- Reference Lines Toggle -->
        <div class="toggle-row">
            <div>
                <div class="toggle-label">Reference Lines</div>
                <div class="toggle-desc">Show alignment guides on key frames</div>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="referenceLinesToggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <!-- Hand Path Toggle -->
        <div class="toggle-row">
            <div>
                <div class="toggle-label">Hand Path</div>
                <div class="toggle-desc">Show hand trail on replay</div>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="handPathToggle">
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <!-- Handedness Selector -->
        <div class="toggle-row">
            <div>
                <div class="toggle-label">Golfer Handedness</div>
                <div class="toggle-desc">Adjusts framing to show ball</div>
            </div>
            <div class="handedness-selector">
                <button class="hand-btn active" id="rightHandBtn" data-hand="right">Right</button>
                <button class="hand-btn" id="leftHandBtn" data-hand="left">Left</button>
            </div>
        </div>
        
        <!-- Upload Section -->
        <section class="section" id="uploadSection">
            <div class="section-label">Upload Swing Video</div>
            <div class="upload-area" id="uploadArea">
                <svg class="upload-icon" viewBox="0 0 56 56" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="8" y="8" width="40" height="40" rx="8"/>
                    <path d="M28 20v16M20 28l8-8 8 8"/>
                    <path d="M18 40h20"/>
                </svg>
                <p class="upload-text">Tap to select video</p>
                <p class="upload-hint">Or drag and drop here</p>
            </div>
            <input type="file" id="videoInput" accept="video/*">
        </section>
        
        <!-- Video Preview -->
        <div class="video-container" id="videoContainer">
            <video id="videoPreview" playsinline muted></video>
            <canvas id="canvasOverlay"></canvas>
        </div>
        
        <!-- Video Controls -->
        <div class="video-controls" id="videoControls" style="display: none;">
            <button class="btn btn-secondary" id="changeVideoBtn">Change Video</button>
            <button class="btn btn-primary" id="analyzeBtn">
                Analyze Swing
            </button>
        </div>
        
        <!-- Progress -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <p class="progress-text" id="progressText">Initializing analysis...</p>
        </div>
        
        <!-- Results Section -->
        <section class="results-section" id="resultsSection">
            <div class="section-label">Key Positions</div>
            <div class="keyframes-grid" id="keyframesGrid">
                <div class="keyframe-card">
                    <canvas class="keyframe-canvas" id="addressCanvas"></canvas>
                    <div class="keyframe-label">Address</div>
                </div>
                <div class="keyframe-card">
                    <canvas class="keyframe-canvas" id="topCanvas"></canvas>
                    <div class="keyframe-label">Top</div>
                </div>
                <div class="keyframe-card">
                    <canvas class="keyframe-canvas" id="impactCanvas"></canvas>
                    <div class="keyframe-label">Impact</div>
                    <div class="impact-adjust" id="impactAdjust">
                        <button class="adjust-btn" data-step="-5" title="5 frames earlier">5</button>
                        <button class="adjust-btn" data-step="-1" title="1 frame earlier">1</button>
                        <span class="adjust-offset" id="impactOffsetDisplay">0</span>
                        <button class="adjust-btn" data-step="1" title="1 frame later">+1</button>
                        <button class="adjust-btn" data-step="5" title="5 frames later">+5</button>
                    </div>
                </div>
                <div class="keyframe-card">
                    <canvas class="keyframe-canvas" id="finishCanvas"></canvas>
                    <div class="keyframe-label">Finish</div>
                </div>
            </div>
            
            <!-- Swing Replay Player -->
            <div class="replay-section">
                <div class="section-label">Swing Replay</div>
                <div class="replay-container">
                    <canvas class="replay-canvas" id="replayCanvas"></canvas>
                    <div class="replay-controls">
                        <button class="replay-btn" id="replayPrevFrame" title="Previous Frame">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                                <line x1="5" y1="19" x2="5" y2="5"></line>
                            </svg>
                        </button>
                        <button class="replay-btn replay-btn-main" id="replayPlayPause" title="Play/Pause">
                            <svg class="play-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            <svg class="pause-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="display:none;">
                                <rect x="6" y="4" width="4" height="16"></rect>
                                <rect x="14" y="4" width="4" height="16"></rect>
                            </svg>
                        </button>
                        <button class="replay-btn" id="replayNextFrame" title="Next Frame">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                                <line x1="19" y1="5" x2="19" y2="19"></line>
                            </svg>
                        </button>
                    </div>
                    <div class="replay-scrubber">
                        <input type="range" id="replayScrubber" min="0" max="100" value="0">
                        <div class="replay-frame-info">
                            <span id="replayCurrentFrame">0</span> / <span id="replayTotalFrames">0</span>
                        </div>
                    </div>
                    <div class="replay-speed">
                        <label>Speed:</label>
                        <select id="replaySpeed">
                            <option value="0.25">0.25x</option>
                            <option value="0.5" selected>0.5x</option>
                            <option value="1">1x</option>
                        </select>
                    </div>
                    
                    <!-- Ghost Mode Controls -->
                    <div class="ghost-mode-controls">
                        <div class="ghost-toggle-row">
                            <label class="ghost-toggle">
                                <input type="checkbox" id="ghostModeToggle">
                                <span class="ghost-toggle-label"> Ghost Mode</span>
                            </label>
                            <select id="ghostProSelect" class="ghost-pro-select" disabled>
                                <option value="">No pros loaded</option>
                            </select>
                        </div>
                        <div class="ghost-legend" id="ghostLegend" style="display:none;">
                            <span class="legend-you"> Your Swing</span>
                            <span class="legend-pro"> Pro Swing</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Drawing/Annotation Tools -->
            <div class="drawing-section">
                <div class="section-label">
                    <span>Frame Annotation</span>
                    <button class="btn-icon" id="toggleDrawingMode" title="Open Drawing Mode">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                            <path d="M2 2l7.586 7.586"></path>
                            <circle cx="11" cy="11" r="2"></circle>
                        </svg>
                        Open Drawing Mode
                    </button>
                </div>
            </div>
            
            <!-- Drawing Mode Modal -->
            <div class="drawing-modal" id="drawingModal">
                <!-- Canvas Area -->
                <div class="drawing-canvas-container" id="drawingCanvasContainer">
                    <div class="drawing-canvas-wrapper">
                        <canvas id="drawingCanvasBg"></canvas>
                        <canvas id="drawingCanvas"></canvas>
                    </div>
                </div>
                
                <!-- Close Button - Top Left -->
                <button class="drawing-close-btn" id="closeDrawingModal">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
                
                <!-- Tools Dropdown - Top Right -->
                <div class="drawing-tools-dropdown">
                    <button class="tools-toggle-btn" id="toolsToggleBtn">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                        </svg>
                    </button>
                    <div class="tools-menu" id="toolsMenu">
                        <div class="tools-section">
                            <div class="tools-section-label">Shape</div>
                            <div class="tools-row">
                                <button class="tool-btn active" data-tool="line" title="Line">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="5" y1="19" x2="19" y2="5"></line>
                                    </svg>
                                </button>
                                <button class="tool-btn" data-tool="arrow" title="Arrow">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="5" y1="19" x2="19" y2="5"></line>
                                        <polyline points="12 5 19 5 19 12"></polyline>
                                    </svg>
                                </button>
                                <button class="tool-btn" data-tool="circle" title="Circle">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="8"></circle>
                                    </svg>
                                </button>
                                <button class="tool-btn" data-tool="freehand" title="Freehand">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 17c3-3 6-11 9-11s3 8 6 8 3-4 3-4"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="tools-section">
                            <div class="tools-section-label">Color</div>
                            <div class="tools-row">
                                <button class="color-btn active" data-color="#ef4444" style="background:#ef4444;" title="Red"></button>
                                <button class="color-btn" data-color="#f59e0b" style="background:#f59e0b;" title="Orange"></button>
                                <button class="color-btn" data-color="#22c55e" style="background:#22c55e;" title="Green"></button>
                                <button class="color-btn" data-color="#3b82f6" style="background:#3b82f6;" title="Blue"></button>
                                <button class="color-btn" data-color="#ffffff" style="background:#ffffff;" title="White"></button>
                            </div>
                        </div>
                        <div class="tools-section">
                            <div class="tools-section-label">Actions</div>
                            <div class="tools-row">
                                <button class="action-btn" id="undoDrawing" title="Undo">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="1 4 1 10 7 10"></polyline>
                                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                                    </svg>
                                </button>
                                <button class="action-btn" id="clearDrawing" title="Clear All">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    </svg>
                                </button>
                                <button class="action-btn save" id="saveDrawing" title="Save Image">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="7 10 12 15 17 10"></polyline>
                                        <line x1="12" y1="15" x2="12" y2="3"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Zoom Controls - Bottom Left -->
                <div class="drawing-zoom-controls">
                    <button class="zoom-btn" id="zoomOut" title="Zoom Out"></button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="zoom-btn" id="zoomIn" title="Zoom In">+</button>
                </div>
                
                <!-- Frame Navigation - Bottom Center -->
                <div class="drawing-frame-nav">
                    <button class="btn-nav" id="drawingPrevFrame"></button>
                    <div class="drawing-frame-selector">
                        <button class="frame-btn active" data-frame="address">Address</button>
                        <button class="frame-btn" data-frame="top">Top</button>
                        <button class="frame-btn" data-frame="impact">Impact</button>
                        <button class="frame-btn" data-frame="finish">Finish</button>
                    </div>
                    <button class="btn-nav" id="drawingNextFrame"></button>
                </div>
                
                <!-- Current Tool Indicator - Bottom Right -->
                <div class="current-tool-indicator">
                    <span class="current-tool-label" id="currentToolLabel">Line</span>
                    <div class="current-color-dot" id="currentColorDot" style="background:#ef4444;"></div>
                </div>
            </div>
            
            <div class="reference-legend" id="referenceLegend">
                <div class="legend-item">
                    <div class="legend-line spine"></div>
                    <span class="legend-text">Spine Angle</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line head"></div>
                    <span class="legend-text">Head Position</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line shoulders"></div>
                    <span class="legend-text">Shoulders</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line hips"></div>
                    <span class="legend-text">Hips</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line swing-plane"></div>
                    <span class="legend-text">Swing Plane</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle ball"></div>
                    <span class="legend-text">Ball Position</span>
                </div>
            </div>
            
            <!-- Stats Summary Section -->
            <div class="stats-summary" id="statsSummary">
                <div class="stats-header">
                    <h2 class="stats-title">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--accent-green)" stroke-width="2">
                            <path d="M18 20V10M12 20V4M6 20v-6"/>
                        </svg>
                        Swing Stats
                    </h2>
                    <div class="swing-score" id="swingScore">
                        <span class="score-value">--</span>
                        <span class="score-label">Score</span>
                        <span class="club-indicator" id="clubIndicator"></span>
                    </div>
                </div>
                
                <!-- Basic Stats Grid -->
                <div class="stats-grid" id="basicStatsGrid">
                    <!-- Populated by JS -->
                </div>
                
                <!-- View More Toggle -->
                <button class="view-more-btn" id="viewMoreStatsBtn">
                    <span>View More Stats</span>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </button>
                
                <!-- Advanced Stats (Hidden by default) -->
                <div class="advanced-stats" id="advancedStats">
                    <div class="stats-category">
                        <h4 class="stats-category-title">Rotation</h4>
                        <div class="stats-grid" id="rotationStatsGrid"></div>
                    </div>
                    <div class="stats-category">
                        <h4 class="stats-category-title">Stability</h4>
                        <div class="stats-grid" id="stabilityStatsGrid"></div>
                    </div>
                    <div class="stats-category">
                        <h4 class="stats-category-title">Timing</h4>
                        <div class="stats-grid" id="timingStatsGrid"></div>
                    </div>
                    <div class="stats-category">
                        <h4 class="stats-category-title">Positions</h4>
                        <div class="stats-grid" id="positionsStatsGrid"></div>
                    </div>
                </div>
            </div>
            
            <div class="tips-container">
                <h2 class="tips-header">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--accent-green)" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                    </svg>
                    Swing Analysis
                </h2>
                <div id="tipsContainer"></div>
                
                <div class="measurements" id="measurementsContainer"></div>
            </div>
            
            <div class="reset-section">
                <button class="btn btn-secondary" id="resetBtn" style="width: 100%;">
                    Analyze Another Swing
                </button>
            </div>
        </section>
        </div><!-- End Analyze Mode -->
        
        <!-- COMPARE MODE -->
        <div class="mode-content" id="compareMode">
            <section class="section">
                <div class="section-label">Camera Angle</div>
                <div class="angle-selector">
                    <div class="angle-option">
                        <input type="radio" name="compareAngle" id="compareFaceon" value="faceon" checked>
                        <label for="compareFaceon">
                            <svg class="angle-icon" viewBox="0 0 48 48" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="24" cy="12" r="6"/>
                                <path d="M24 18v12M18 24h12M20 30l-4 14M28 30l4 14"/>
                                <rect x="8" y="4" width="32" height="40" rx="2" stroke-dasharray="4 2"/>
                            </svg>
                            <span class="angle-name">Face-On</span>
                            <span class="angle-desc">Camera facing you</span>
                        </label>
                    </div>
                    <div class="angle-option">
                        <input type="radio" name="compareAngle" id="compareDtl" value="dtl">
                        <label for="compareDtl">
                            <svg class="angle-icon" viewBox="0 0 48 48" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="20" cy="12" r="6"/>
                                <path d="M20 18v12M20 30l-2 14M20 30l6 12"/>
                                <path d="M20 24l10-6" stroke-linecap="round"/>
                                <rect x="8" y="4" width="32" height="40" rx="2" stroke-dasharray="4 2"/>
                            </svg>
                            <span class="angle-name">Down-the-Line</span>
                            <span class="angle-desc">Camera behind you</span>
                        </label>
                    </div>
                </div>
            </section>
            
            <!-- Pro Selection -->
            <section class="section">
                <div class="section-label">Select Pro to Compare</div>
                <div class="pro-selector">
                    <div class="pro-grid" id="proGrid">
                        <div class="pro-card selected" data-pro="tiger">
                            <div class="pro-avatar"></div>
                            <div class="pro-name">Tiger Woods</div>
                            <div class="pro-desc">Power & Precision</div>
                            <div class="pro-video-badge" title="Video available"></div>
                        </div>
                        <div class="pro-card" data-pro="rory">
                            <div class="pro-avatar"></div>
                            <div class="pro-name">Rory McIlroy</div>
                            <div class="pro-desc">Athletic Turn</div>
                            <div class="pro-video-badge" title="Video available"></div>
                        </div>
                        <div class="pro-card" data-pro="scottie">
                            <div class="pro-avatar"></div>
                            <div class="pro-name">Scottie Scheffler</div>
                            <div class="pro-desc">Modern Power</div>
                        </div>
                        <div class="pro-card" data-pro="nelly">
                            <div class="pro-avatar"></div>
                            <div class="pro-name">Nelly Korda</div>
                            <div class="pro-desc">Smooth Tempo</div>
                        </div>
                    </div>
                </div>
                
                <!-- Pro Video Reference -->
                <div class="pro-video-section" id="proVideoSection" style="display: none;">
                    <div class="section-label">Pro Reference Video</div>
                    <div class="pro-video-container">
                        <div class="pro-video-player" id="proVideoPlayer">
                            <div class="video-placeholder">
                                <span>Select club type and camera angle to view pro swing</span>
                            </div>
                        </div>
                        <div class="pro-video-controls">
                            <select id="proVideoClubSelect" class="video-select">
                                <option value="driver">Driver</option>
                                <option value="iron">Iron</option>
                            </select>
                            <select id="proVideoAngleSelect" class="video-select">
                                <option value="faceon">Face-On</option>
                                <option value="dtl">Down-the-Line</option>
                            </select>
                            <button class="btn btn-small" id="watchProVideoBtn">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <polygon points="5,3 19,12 5,21"/>
                                </svg>
                                Watch
                            </button>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- User Swing Upload -->
            <section class="section">
                <div class="section-label">Upload Your Swing</div>
                <div class="upload-area" id="compareUploadArea">
                    <svg class="upload-icon" viewBox="0 0 56 56" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="8" y="8" width="40" height="40" rx="8"/>
                        <path d="M28 20v16M20 28l8-8 8 8"/>
                        <path d="M18 40h20"/>
                    </svg>
                    <p class="upload-text">Tap to select your swing video</p>
                    <p class="upload-hint">We'll compare it to the pro</p>
                </div>
                <input type="file" id="compareVideoInput" accept="video/*" style="display:none">
                
                <div class="user-video-loaded" id="userVideoLoaded" style="display: none;">
                    <div class="loaded-indicator">
                        <span class="checkmark"></span>
                        <span class="loaded-text">Your swing loaded</span>
                        <button class="btn-small" id="changeUserVideoBtn">Change</button>
                    </div>
                </div>
                
                <button class="btn btn-primary" id="compareBtn" disabled style="width: 100%; margin-top: 16px;">
                    Compare to Pro
                </button>
            </section>
            
            <!-- Compare Progress -->
            <div class="progress-container" id="compareProgressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="compareProgressFill" style="width: 0%"></div>
                </div>
                <p class="progress-text" id="compareProgressText">Analyzing your swing...</p>
            </div>
            
            <!-- Comparison Results -->
            <div class="comparison-container" id="comparisonResults">
                <div class="comparison-header">
                    <div class="comparing-to">
                        <span class="compare-label">Comparing to</span>
                        <span class="pro-name-display" id="proNameDisplay">Tiger Woods</span>
                    </div>
                </div>
                
                <div class="section-label">Compare Positions</div>
                
                <div class="comparison-phase-selector" id="phaseSelector">
                    <button class="phase-btn active" data-phase="address">Address</button>
                    <button class="phase-btn" data-phase="top">Top</button>
                    <button class="phase-btn" data-phase="impact">Impact</button>
                    <button class="phase-btn" data-phase="finish">Finish</button>
                </div>
                
                <div class="comparison-view" id="comparisonView">
                    <div class="comparison-frame swing-a">
                        <canvas id="compareCanvasUser"></canvas>
                        <div class="frame-label">Your Swing</div>
                    </div>
                    <div class="comparison-frame swing-b pro-frame">
                        <canvas id="compareCanvasPro"></canvas>
                        <div class="frame-label">Pro Reference</div>
                    </div>
                </div>
                
                <div class="comparison-metrics">
                    <h3>How You Compare</h3>
                    <div id="comparisonMetrics"></div>
                </div>
                
                <div class="pro-tips-section">
                    <h3 class="tips-header">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--accent-blue)" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 16v-4M12 8h.01"/>
                        </svg>
                        Pro Tips
                    </h3>
                    <div id="proTipsContainer"></div>
                </div>
                
                <div class="reset-section">
                    <button class="btn btn-secondary" id="resetCompareBtn" style="width: 100%;">
                        Try Another Comparison
                    </button>
                </div>
            </div>
        </div><!-- End Compare Mode -->
    </div>
    
    <script>
        // ========================================
        // GOLF SWING ANALYZER - MAIN APPLICATION
        // ========================================
        
        class GolfSwingAnalyzer {
            constructor() {
                this.pose = null;
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isProcessing = false;
                this.framesData = [];
                this.keyFrames = {};
                this.impactOffset = 0; // Manual impact adjustment (-2 to +2 frames)
                this.originalImpactIdx = null; // Store original detected impact index
                this.cameraAngle = 'faceon';
                this.clubType = 'driver'; // 'driver' or 'iron'
                this.autoCropEnabled = true;
                this.referenceLinesEnabled = true;
                this.handPathEnabled = false;
                this.golferHandedness = 'right';
                this.cropRegion = null;
                
                // Pre-detected swing phases from boundary detection
                this.preDetectedPhases = null;
                
                // Replay state
                this.replayFrameIndex = 0;
                this.isPlaying = false;
                this.replayInterval = null;
                
                // Drawing tool state
                this.drawingTool = 'line';
                this.drawingColor = '#ef4444';
                this.drawingHistory = [];
                this.currentDrawingFrame = 'address';
                this.drawingZoom = 1;
                this.drawingPan = { x: 0, y: 0 };
                this.isDrawing = false;
                this.drawStart = { x: 0, y: 0 };
                this.freehandPoints = [];
                this.frameDrawings = { address: [], top: [], impact: [], finish: [] };
                
                // Ghost mode state
                this.ghostModeEnabled = false;
                this.selectedGhostPro = null;
                
                // Pro skeleton data - will be populated with real extracted data
                // Structure: { proId: { name, color, driver: { dtl: {...}, faceon: {...} }, iron: { dtl: {...}, faceon: {...} } } }
                // Each angle contains phases: { address, top, impact, finish }
                // Each phase contains landmarks array with 33 points matching MediaPipe format
                this.proSkeletons = {};
                
                // Club-specific configurations
                this.clubConfigs = {
                    driver: {
                        name: 'Driver',
                        ballPosition: 'front', // Off lead heel
                        ballOffsetMultiplier: 3.0, // More forward
                        idealRanges: {
                            tempo: { min: 2.8, max: 3.5, label: '2.8-3.5:1' },
                            shoulderTurn: { min: 90, max: 105, label: '90-105' },
                            hipTurn: { min: 40, max: 55, label: '40-55' },
                            xFactor: { min: 40, max: 55, label: '40-55' },
                            spineAngle: { min: 30, max: 40, label: '30-40' },
                            attackAngle: { min: 2, max: 5, label: '+2 to +5 (up)' }
                        },
                        tipModifiers: {
                            address: 'With driver, ball should be positioned off your lead heel. Spine tilts slightly away from target.',
                            top: 'Driver allows for a fuller shoulder turn. Feel width at the top.',
                            impact: 'Hit up on the ball (+3-5 attack angle). Head stays well behind the ball.',
                            finish: 'Full extension through the ball with complete rotation to finish.'
                        },
                        commonFaults: [
                            { id: 'ball_too_far_back', message: 'Ball position may be too far back for driver - move it forward to lead heel' },
                            { id: 'hitting_down', message: 'Avoid hitting down on driver - sweep the ball with an ascending blow' },
                            { id: 'narrow_stance', message: 'Widen your stance for driver to create a stable base' }
                        ]
                    },
                    iron: {
                        name: 'Iron',
                        ballPosition: 'center', // Center to slightly forward
                        ballOffsetMultiplier: 2.0, // More centered
                        idealRanges: {
                            tempo: { min: 2.5, max: 3.2, label: '2.5-3.2:1' },
                            shoulderTurn: { min: 85, max: 95, label: '85-95' },
                            hipTurn: { min: 35, max: 50, label: '35-50' },
                            xFactor: { min: 35, max: 50, label: '35-50' },
                            spineAngle: { min: 32, max: 42, label: '32-42' },
                            attackAngle: { min: -5, max: -2, label: '-2 to -5 (down)' }
                        },
                        tipModifiers: {
                            address: 'Ball position varies: center for short irons, slightly forward for long irons.',
                            top: 'Slightly shorter backswing than driver. Focus on control over power.',
                            impact: 'Hit down and through the ball. Divot should be after the ball.',
                            finish: 'Balanced finish with weight on lead side. Slightly shorter follow-through than driver.'
                        },
                        commonFaults: [
                            { id: 'scooping', message: 'Avoid trying to lift the ball - trust the loft and hit down' },
                            { id: 'ball_too_forward', message: 'Ball may be too far forward for irons - move it back toward center' },
                            { id: 'swaying', message: 'Minimize lateral movement - rotate around a stable spine' }
                        ]
                    }
                };
                
                // Comparison mode
                this.compareMode = false;
                this.selectedPro = 'tiger';
                this.userSwing = { file: null, framesData: [], keyFrames: {}, measurements: {} };
                this.compareAngle = 'faceon';
                this.currentComparePhase = 'address';
                
                // Pro reference data (ideal measurements based on swing analysis)
                this.proData = {
                    tiger: {
                        name: 'Tiger Woods',
                        style: 'Power & Precision',
                        color: '#f59e0b',
                        videos: {
                            driver: {
                                faceon: 'https://www.youtube.com/watch?v=Jlp8G9paliw',
                                dtl: null
                            },
                            iron: {
                                faceon: 'https://www.youtube.com/watch?v=EmLyMDyCbto',
                                dtl: null
                            }
                        },
                        // Reference images for each phase and angle
                        // Replace these placeholder URLs with actual hosted images
                        images: {
                            faceon: {
                                // Tiger Woods face-on swing images
                                address: null, // Add URL like: 'https://your-hosting.com/tiger-faceon-address.jpg'
                                top: null,
                                impact: null,
                                finish: null
                            },
                            dtl: {
                                // Tiger Woods DTL swing images
                                address: null,
                                top: null,
                                impact: null,
                                finish: null
                            }
                        },
                        driver: {
                            faceon: {
                                shoulderTurn: 95,
                                hipTurn: 45,
                                xFactor: 50,
                                spineTilt: 6,
                                tempo: 3.2,
                                traits: ['Full shoulder turn', 'Powerful hip restriction', 'Slight spine tilt away at address']
                            },
                            dtl: {
                                spineAngle: 35,
                                hipDepth: 'maintained',
                                headMovement: 'minimal',
                                traits: ['Maintains spine angle through impact', 'No early extension', 'Head stays behind ball']
                            }
                        },
                        iron: {
                            faceon: {
                                shoulderTurn: 90,
                                hipTurn: 42,
                                xFactor: 48,
                                spineTilt: 5,
                                tempo: 3.0,
                                traits: ['Controlled backswing', 'Steeper attack angle', 'Ball-first contact']
                            },
                            dtl: {
                                spineAngle: 38,
                                hipDepth: 'maintained',
                                headMovement: 'minimal',
                                traits: ['Shaft lean at impact', 'Divot after ball', 'Maintains posture']
                            }
                        },
                        tips: {
                            driver: {
                                address: 'Tiger sets up with ball off lead heel, slight spine tilt away from target.',
                                top: 'Notice the massive shoulder turn (90+) while restricting hip turn to create coil.',
                                impact: 'Head stays well behind the ball - hitting up on driver for optimal launch.',
                                finish: 'Full rotation to a balanced finish, belt buckle facing target.'
                            },
                            iron: {
                                address: 'Ball position more centered, weight slightly favoring lead side.',
                                top: 'Slightly shorter backswing than driver, maintaining width.',
                                impact: 'Hands ahead of clubhead, compressing the ball with descending blow.',
                                finish: 'Controlled finish, weight fully transferred to lead side.'
                            }
                        }
                    },
                    rory: {
                        name: 'Rory McIlroy',
                        style: 'Athletic Turn',
                        color: '#3b82f6',
                        videos: {
                            driver: {
                                faceon: 'https://www.youtube.com/watch?v=P3YksJdejog',
                                dtl: null
                            },
                            iron: {
                                faceon: null,
                                dtl: 'https://www.youtube.com/shorts/A0ty-e8e5cc'
                            }
                        },
                        images: {
                            faceon: {
                                address: null,
                                top: null,
                                impact: null,
                                finish: null
                            },
                            dtl: {
                                address: null,
                                top: null,
                                impact: null,
                                finish: null
                            }
                        },
                        driver: {
                            faceon: {
                                shoulderTurn: 92,
                                hipTurn: 50,
                                xFactor: 42,
                                spineTilt: 5,
                                tempo: 2.9,
                                traits: ['Athletic setup', 'Free hip turn', 'Fast transition']
                            },
                            dtl: {
                                spineAngle: 32,
                                hipDepth: 'maintained',
                                headMovement: 'slight drop',
                                traits: ['Maintains tush line', 'Slight squat in transition', 'Aggressive rotation']
                            }
                        },
                        iron: {
                            faceon: {
                                shoulderTurn: 88,
                                hipTurn: 45,
                                xFactor: 43,
                                spineTilt: 4,
                                tempo: 2.8,
                                traits: ['Compact backswing', 'Explosive transition', 'Pure strike']
                            },
                            dtl: {
                                spineAngle: 34,
                                hipDepth: 'maintained',
                                headMovement: 'minimal',
                                traits: ['Perfect plane', 'Shaft lean at impact', 'Aggressive release']
                            }
                        },
                        tips: {
                            driver: {
                                address: 'Rory uses a more athletic, slightly wider stance for stability.',
                                top: 'Full turn with more hip freedom than Tiger - suits his rotational style.',
                                impact: 'Notice the ground force - his legs drive hard creating massive speed.',
                                finish: 'High hands, full release, perfectly balanced despite aggressive rotation.'
                            },
                            iron: {
                                address: 'Athletic posture, ready to rotate aggressively.',
                                top: 'Compact but powerful, maintaining connection between arms and body.',
                                impact: 'Aggressive rotation through the ball, taking a divot after impact.',
                                finish: 'Full release with weight completely on lead foot.'
                            }
                        }
                    },
                    scottie: {
                        name: 'Scottie Scheffler',
                        style: 'Modern Power',
                        color: '#10b981',
                        videos: {
                            driver: {
                                faceon: null,
                                dtl: null
                            },
                            iron: {
                                faceon: null,
                                dtl: null
                            }
                        },
                        images: {
                            faceon: {
                                address: null,
                                top: null,
                                impact: null,
                                finish: null
                            },
                            dtl: {
                                address: null,
                                top: null,
                                impact: null,
                                finish: null
                            }
                        },
                        driver: {
                            faceon: {
                                shoulderTurn: 94,
                                hipTurn: 48,
                                xFactor: 46,
                                spineTilt: 7,
                                tempo: 3.1,
                                traits: ['Strong grip', 'Squat in transition', 'Powerful leg drive']
                            },
                            dtl: {
                                spineAngle: 36,
                                hipDepth: 'maintained',
                                headMovement: 'minimal',
                                traits: ['On plane throughout', 'Maintains angles', 'Explosive release']
                            }
                        },
                        iron: {
                            faceon: {
                                shoulderTurn: 90,
                                hipTurn: 44,
                                xFactor: 46,
                                spineTilt: 5,
                                tempo: 3.0,
                                traits: ['Consistent positions', 'Great rhythm', 'Controlled power']
                            },
                            dtl: {
                                spineAngle: 38,
                                hipDepth: 'maintained',
                                headMovement: 'minimal',
                                traits: ['Textbook plane', 'Shaft lean', 'Balanced finish']
                            }
                        },
                        tips: {
                            driver: {
                                address: 'Scottie sets up with a slightly stronger grip, promoting a draw.',
                                top: 'Notice the squat move in transition - loading into the ground.',
                                impact: 'Explosive leg drive while maintaining upper body angles.',
                                finish: 'Full rotation with excellent balance.'
                            },
                            iron: {
                                address: 'Solid fundamentals with consistent pre-shot routine.',
                                top: 'Maintains width and achieves full shoulder turn.',
                                impact: 'Compresses the ball beautifully with forward shaft lean.',
                                finish: 'Balanced finish every time - hallmark of consistency.'
                            }
                        }
                    },
                    nelly: {
                        name: 'Nelly Korda',
                        style: 'Smooth Tempo',
                        color: '#ec4899',
                        videos: {
                            driver: {
                                faceon: null,
                                dtl: null
                            },
                            iron: {
                                faceon: null,
                                dtl: null
                            }
                        },
                        images: {
                            faceon: {
                                address: null,
                                top: null,
                                impact: null,
                                finish: null
                            },
                            dtl: {
                                address: null,
                                top: null,
                                impact: null,
                                finish: null
                            }
                        },
                        driver: {
                            faceon: {
                                shoulderTurn: 88,
                                hipTurn: 52,
                                xFactor: 36,
                                spineTilt: 4,
                                tempo: 3.3,
                                traits: ['Effortless power', 'Smooth transition', 'Great rhythm']
                            },
                            dtl: {
                                spineAngle: 30,
                                hipDepth: 'maintained',
                                headMovement: 'minimal',
                                traits: ['Perfect posture', 'Smooth tempo', 'Efficient motion']
                            }
                        },
                        iron: {
                            faceon: {
                                shoulderTurn: 85,
                                hipTurn: 48,
                                xFactor: 37,
                                spineTilt: 3,
                                tempo: 3.2,
                                traits: ['Smooth rhythm', 'Controlled power', 'Consistent tempo']
                            },
                            dtl: {
                                spineAngle: 32,
                                hipDepth: 'maintained',
                                headMovement: 'minimal',
                                traits: ['On plane', 'Great balance', 'Effortless power']
                            }
                        },
                        tips: {
                            driver: {
                                address: 'Nelly\'s setup emphasizes balance and relaxed arms.',
                                top: 'Smooth, unhurried backswing - notice the tempo.',
                                impact: 'Effortless power through efficient sequencing.',
                                finish: 'Balanced finish shows great rhythm throughout.'
                            },
                            iron: {
                                address: 'Relaxed setup with soft arms and good posture.',
                                top: 'Controlled backswing, never rushed.',
                                impact: 'Clean strike with great compression.',
                                finish: 'Perfectly balanced, ready to do it again.'
                            }
                        }
                    }
                };
                
                // MediaPipe keypoint indices
                this.KEYPOINTS = {
                    NOSE: 0,
                    LEFT_SHOULDER: 11,
                    RIGHT_SHOULDER: 12,
                    LEFT_ELBOW: 13,
                    RIGHT_ELBOW: 14,
                    LEFT_WRIST: 15,
                    RIGHT_WRIST: 16,
                    LEFT_HIP: 23,
                    RIGHT_HIP: 24,
                    LEFT_KNEE: 25,
                    RIGHT_KNEE: 26,
                    LEFT_ANKLE: 27,
                    RIGHT_ANKLE: 28
                };
                
                this.init();
            }
            
            async init() {
                this.bindElements();
                this.bindEvents();
                await this.initMediaPipe();
            }
            
            bindElements() {
                this.uploadArea = document.getElementById('uploadArea');
                this.videoInput = document.getElementById('videoInput');
                this.videoContainer = document.getElementById('videoContainer');
                this.videoPreview = document.getElementById('videoPreview');
                this.canvasOverlay = document.getElementById('canvasOverlay');
                this.videoControls = document.getElementById('videoControls');
                this.analyzeBtn = document.getElementById('analyzeBtn');
                this.changeVideoBtn = document.getElementById('changeVideoBtn');
                this.progressContainer = document.getElementById('progressContainer');
                this.progressFill = document.getElementById('progressFill');
                this.progressText = document.getElementById('progressText');
                this.resultsSection = document.getElementById('resultsSection');
                this.uploadSection = document.getElementById('uploadSection');
                this.resetBtn = document.getElementById('resetBtn');
                
                // New elements
                this.autoCropToggle = document.getElementById('autoCropToggle');
                this.referenceLinesToggle = document.getElementById('referenceLinesToggle');
                this.handPathToggle = document.getElementById('handPathToggle');
                this.rightHandBtn = document.getElementById('rightHandBtn');
                this.leftHandBtn = document.getElementById('leftHandBtn');
                this.driverBtn = document.getElementById('driverBtn');
                this.ironBtn = document.getElementById('ironBtn');
                this.modeTabs = document.querySelectorAll('.mode-tab');
                this.analyzeMode = document.getElementById('analyzeMode');
                this.compareMode = document.getElementById('compareMode');
                
                // Pro comparison elements
                this.proGrid = document.getElementById('proGrid');
                this.compareUploadArea = document.getElementById('compareUploadArea');
                this.compareVideoInput = document.getElementById('compareVideoInput');
                this.userVideoLoaded = document.getElementById('userVideoLoaded');
                this.changeUserVideoBtn = document.getElementById('changeUserVideoBtn');
                this.compareBtn = document.getElementById('compareBtn');
                this.compareProgressContainer = document.getElementById('compareProgressContainer');
                this.compareProgressFill = document.getElementById('compareProgressFill');
                this.compareProgressText = document.getElementById('compareProgressText');
                this.comparisonResults = document.getElementById('comparisonResults');
                this.proNameDisplay = document.getElementById('proNameDisplay');
                this.phaseSelector = document.getElementById('phaseSelector');
                this.comparisonView = document.getElementById('comparisonView');
                this.resetCompareBtn = document.getElementById('resetCompareBtn');
                
                // Pro video reference elements
                this.proVideoSection = document.getElementById('proVideoSection');
                this.proVideoPlayer = document.getElementById('proVideoPlayer');
                this.proVideoClubSelect = document.getElementById('proVideoClubSelect');
                this.proVideoAngleSelect = document.getElementById('proVideoAngleSelect');
                this.watchProVideoBtn = document.getElementById('watchProVideoBtn');
                
                // Replay elements
                this.replayCanvas = document.getElementById('replayCanvas');
                this.replayPrevFrame = document.getElementById('replayPrevFrame');
                this.replayNextFrame = document.getElementById('replayNextFrame');
                this.replayPlayPause = document.getElementById('replayPlayPause');
                this.replayScrubber = document.getElementById('replayScrubber');
                this.replayCurrentFrame = document.getElementById('replayCurrentFrame');
                this.replayTotalFrames = document.getElementById('replayTotalFrames');
                this.replaySpeed = document.getElementById('replaySpeed');
                
                // Drawing tool elements
                this.toggleDrawingMode = document.getElementById('toggleDrawingMode');
                this.drawingModal = document.getElementById('drawingModal');
                this.closeDrawingModal = document.getElementById('closeDrawingModal');
                this.drawingCanvasContainer = document.getElementById('drawingCanvasContainer');
                this.drawingCanvasBg = document.getElementById('drawingCanvasBg');
                this.drawingCanvas = document.getElementById('drawingCanvas');
                this.drawingPrevFrame = document.getElementById('drawingPrevFrame');
                this.drawingNextFrame = document.getElementById('drawingNextFrame');
                this.undoDrawing = document.getElementById('undoDrawing');
                this.clearDrawing = document.getElementById('clearDrawing');
                this.saveDrawing = document.getElementById('saveDrawing');
                this.zoomIn = document.getElementById('zoomIn');
                this.zoomOut = document.getElementById('zoomOut');
                this.zoomLevelDisplay = document.getElementById('zoomLevel');
                this.toolsToggleBtn = document.getElementById('toolsToggleBtn');
                this.toolsMenu = document.getElementById('toolsMenu');
                this.currentColorDot = document.getElementById('currentColorDot');
                
                // Stats elements
                this.statsSummary = document.getElementById('statsSummary');
                this.swingScoreDisplay = document.getElementById('swingScore');
                this.basicStatsGrid = document.getElementById('basicStatsGrid');
                this.viewMoreStatsBtn = document.getElementById('viewMoreStatsBtn');
                this.advancedStats = document.getElementById('advancedStats');
                
                // Tool indicator
                this.currentToolLabel = document.getElementById('currentToolLabel');
                
                // Ghost mode elements
                this.ghostModeToggle = document.getElementById('ghostModeToggle');
                this.ghostProSelect = document.getElementById('ghostProSelect');
                this.ghostLegend = document.getElementById('ghostLegend');
            }
            
            bindEvents() {
                // Camera angle selection
                document.querySelectorAll('input[name="cameraAngle"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.cameraAngle = e.target.value;
                    });
                });
                
                // Auto-crop toggle
                this.autoCropToggle.addEventListener('change', (e) => {
                    this.autoCropEnabled = e.target.checked;
                });
                
                // Reference lines toggle
                this.referenceLinesToggle.addEventListener('change', (e) => {
                    this.referenceLinesEnabled = e.target.checked;
                });
                
                // Hand path toggle
                this.handPathToggle.addEventListener('change', (e) => {
                    this.handPathEnabled = e.target.checked;
                });
                
                // Ghost mode toggle
                this.ghostModeToggle.addEventListener('change', (e) => {
                    this.ghostModeEnabled = e.target.checked;
                    this.ghostProSelect.disabled = !e.target.checked;
                    this.ghostLegend.style.display = e.target.checked ? 'flex' : 'none';
                    console.log('Ghost mode:', this.ghostModeEnabled, 'Pro:', this.selectedGhostPro, 'Angle:', this.cameraAngle);
                    // Redraw current frame with ghost
                    if (this.framesData && this.framesData.length > 0) {
                        this.renderReplayFrame(this.currentReplayFrame || 0);
                    }
                });
                
                this.ghostProSelect.addEventListener('change', (e) => {
                    this.selectedGhostPro = e.target.value;
                    console.log('Ghost pro changed to:', this.selectedGhostPro);
                    if (this.framesData && this.framesData.length > 0) {
                        this.renderReplayFrame(this.currentReplayFrame || 0);
                    }
                });
                
                // Handedness buttons
                this.rightHandBtn.addEventListener('click', () => {
                    this.golferHandedness = 'right';
                    this.rightHandBtn.classList.add('active');
                    this.leftHandBtn.classList.remove('active');
                });
                this.leftHandBtn.addEventListener('click', () => {
                    this.golferHandedness = 'left';
                    this.leftHandBtn.classList.add('active');
                    this.rightHandBtn.classList.remove('active');
                });
                
                // Club type buttons
                this.driverBtn.addEventListener('click', () => {
                    this.clubType = 'driver';
                    this.driverBtn.classList.add('active');
                    this.ironBtn.classList.remove('active');
                    this.updateGhostProDropdown();
                    this.refreshCurrentView();
                });
                this.ironBtn.addEventListener('click', () => {
                    this.clubType = 'iron';
                    this.ironBtn.classList.add('active');
                    this.driverBtn.classList.remove('active');
                    this.updateGhostProDropdown();
                    this.refreshCurrentView();
                });
                
                // Mode tabs
                this.modeTabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchMode(e.target.dataset.mode);
                    });
                });
                
                // Upload area
                this.uploadArea.addEventListener('click', () => this.videoInput.click());
                this.uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.add('dragover');
                });
                this.uploadArea.addEventListener('dragleave', () => {
                    this.uploadArea.classList.remove('dragover');
                });
                this.uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files.length) {
                        this.handleVideoFile(e.dataTransfer.files[0]);
                    }
                });
                
                // File input
                this.videoInput.addEventListener('change', (e) => {
                    if (e.target.files.length) {
                        this.handleVideoFile(e.target.files[0]);
                    }
                });
                
                // Buttons
                this.analyzeBtn.addEventListener('click', () => this.analyzeSwing());
                this.changeVideoBtn.addEventListener('click', () => this.resetToUpload());
                this.resetBtn.addEventListener('click', () => this.fullReset());
                
                // Impact adjustment buttons
                document.querySelectorAll('.adjust-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const step = parseInt(e.target.dataset.step);
                        this.adjustImpactFrame(step);
                    });
                });
                
                // Compare mode events
                document.querySelectorAll('input[name="compareAngle"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.compareAngle = e.target.value;
                        // Re-render pro reference if comparison is active
                        if (this.comparisonResults.style.display !== 'none' && this.currentComparePhase) {
                            this.renderProReference(this.currentComparePhase);
                        }
                    });
                });
                
                // Pro selection
                this.proGrid.querySelectorAll('.pro-card').forEach(card => {
                    card.addEventListener('click', () => {
                        this.selectPro(card.dataset.pro);
                    });
                });
                
                // Pro video controls
                this.proVideoClubSelect.addEventListener('change', () => this.updateProVideoAvailability());
                this.proVideoAngleSelect.addEventListener('change', () => this.updateProVideoAvailability());
                this.watchProVideoBtn.addEventListener('click', () => this.loadProVideo());
                
                // Compare upload
                this.compareUploadArea.addEventListener('click', () => this.compareVideoInput.click());
                this.compareVideoInput.addEventListener('change', (e) => {
                    if (e.target.files.length) {
                        this.handleCompareVideoFile(e.target.files[0]);
                    }
                });
                
                this.changeUserVideoBtn.addEventListener('click', () => this.resetUserVideo());
                this.compareBtn.addEventListener('click', () => this.runProComparison());
                this.resetCompareBtn.addEventListener('click', () => this.resetComparison());
                
                // Phase selector
                this.phaseSelector.querySelectorAll('.phase-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.selectComparePhase(e.target.dataset.phase);
                    });
                });
                
                // Replay controls
                this.replayPlayPause.addEventListener('click', () => this.toggleReplayPlayback());
                this.replayPrevFrame.addEventListener('click', () => this.replayStepFrame(-1));
                this.replayNextFrame.addEventListener('click', () => this.replayStepFrame(1));
                this.replayScrubber.addEventListener('input', (e) => {
                    this.replaySeekTo(parseInt(e.target.value));
                });
                this.replaySpeed.addEventListener('change', (e) => {
                    // If playing, restart with new speed
                    if (this.isPlaying) {
                        this.stopReplay();
                        this.startReplay();
                    }
                });
                
                // Drawing tool events
                this.toggleDrawingMode.addEventListener('click', () => this.openDrawingMode());
                this.closeDrawingModal.addEventListener('click', () => this.closeDrawingModeModal());
                
                // Tools dropdown toggle
                this.toolsToggleBtn.addEventListener('click', () => this.toggleToolsMenu());
                
                // Close tools menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (this.toolsMenu && this.toolsMenu.classList.contains('visible')) {
                        if (!this.toolsMenu.contains(e.target) && !this.toolsToggleBtn.contains(e.target)) {
                            this.toolsMenu.classList.remove('visible');
                            this.toolsToggleBtn.classList.remove('active');
                        }
                    }
                });
                
                // Tool selection
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.drawingTool = btn.dataset.tool;
                        this.updateToolIndicator();
                    });
                });
                
                // Color selection
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.drawingColor = btn.dataset.color;
                        this.updateToolIndicator();
                    });
                });
                
                // Frame selection
                document.querySelectorAll('.frame-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.selectDrawingFrame(btn.dataset.frame);
                    });
                });
                
                // Frame navigation
                this.drawingPrevFrame.addEventListener('click', () => this.navigateDrawingFrame(-1));
                this.drawingNextFrame.addEventListener('click', () => this.navigateDrawingFrame(1));
                
                // Drawing actions
                this.undoDrawing.addEventListener('click', () => this.undoLastDrawing());
                this.clearDrawing.addEventListener('click', () => this.clearAllDrawings());
                this.saveDrawing.addEventListener('click', () => this.saveAnnotatedFrame());
                
                // Zoom controls
                this.zoomIn.addEventListener('click', () => this.adjustZoom(0.25));
                this.zoomOut.addEventListener('click', () => this.adjustZoom(-0.25));
                
                // View more stats toggle
                this.viewMoreStatsBtn.addEventListener('click', () => this.toggleAdvancedStats());
            }
            
            toggleToolsMenu() {
                this.toolsMenu.classList.toggle('visible');
                this.toolsToggleBtn.classList.toggle('active');
            }
            
            updateToolIndicator() {
                // Update current color dot
                if (this.currentColorDot) {
                    this.currentColorDot.style.background = this.drawingColor;
                }
                
                // Update current tool label
                if (this.currentToolLabel) {
                    const toolNames = {
                        line: 'Line',
                        arrow: 'Arrow',
                        circle: 'Circle',
                        freehand: 'Draw'
                    };
                    this.currentToolLabel.textContent = toolNames[this.drawingTool] || 'Line';
                }
            }
            
            switchMode(mode) {
                this.modeTabs.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.mode === mode);
                });
                this.analyzeMode.classList.toggle('active', mode === 'analyze');
                document.getElementById('compareMode').classList.toggle('active', mode === 'compare');
            }
            
            selectPro(proId) {
                this.selectedPro = proId;
                this.proGrid.querySelectorAll('.pro-card').forEach(card => {
                    card.classList.toggle('selected', card.dataset.pro === proId);
                });
                
                // Show video section if pro has videos
                const pro = this.proData[proId];
                if (pro && pro.videos) {
                    this.proVideoSection.style.display = 'block';
                    this.updateProVideoAvailability();
                } else {
                    this.proVideoSection.style.display = 'none';
                }
            }
            
            updateProVideoAvailability() {
                const pro = this.proData[this.selectedPro];
                if (!pro || !pro.videos) return;
                
                const club = this.proVideoClubSelect.value;
                const angle = this.proVideoAngleSelect.value;
                
                // Check if video is available for selected combination
                const videoUrl = pro.videos[club]?.[angle];
                
                if (videoUrl) {
                    this.watchProVideoBtn.disabled = false;
                    this.watchProVideoBtn.title = 'Watch pro swing';
                } else {
                    this.watchProVideoBtn.disabled = true;
                    this.watchProVideoBtn.title = 'No video available for this combination';
                }
                
                // Update video player placeholder
                if (!videoUrl) {
                    this.proVideoPlayer.innerHTML = `
                        <div class="video-placeholder">
                            <span>No ${club} ${angle === 'faceon' ? 'face-on' : 'DTL'} video available for ${pro.name}</span>
                        </div>
                    `;
                }
            }
            
            loadProVideo() {
                const pro = this.proData[this.selectedPro];
                if (!pro || !pro.videos) return;
                
                const club = this.proVideoClubSelect.value;
                const angle = this.proVideoAngleSelect.value;
                const videoUrl = pro.videos[club]?.[angle];
                
                if (!videoUrl) {
                    alert('No video available for this combination');
                    return;
                }
                
                // Convert YouTube URL to embed URL
                let embedUrl = videoUrl;
                if (videoUrl.includes('youtube.com/watch')) {
                    const videoId = new URL(videoUrl).searchParams.get('v');
                    embedUrl = `https://www.youtube.com/embed/${videoId}?rel=0`;
                } else if (videoUrl.includes('youtube.com/shorts')) {
                    const videoId = videoUrl.split('/shorts/')[1].split('?')[0];
                    embedUrl = `https://www.youtube.com/embed/${videoId}?rel=0`;
                } else if (videoUrl.includes('youtu.be')) {
                    const videoId = videoUrl.split('youtu.be/')[1].split('?')[0];
                    embedUrl = `https://www.youtube.com/embed/${videoId}?rel=0`;
                }
                
                this.proVideoPlayer.innerHTML = `
                    <iframe 
                        src="${embedUrl}" 
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                        allowfullscreen>
                    </iframe>
                `;
            }
            
            handleCompareVideoFile(file) {
                if (!file.type.startsWith('video/')) {
                    alert('Please select a video file');
                    return;
                }
                
                this.userSwing.file = file;
                
                // Update UI
                this.compareUploadArea.style.display = 'none';
                this.userVideoLoaded.style.display = 'block';
                this.compareBtn.disabled = false;
            }
            
            resetUserVideo() {
                this.userSwing = { file: null, framesData: [], keyFrames: {}, measurements: {} };
                this.compareUploadArea.style.display = 'block';
                this.userVideoLoaded.style.display = 'none';
                this.compareBtn.disabled = true;
                this.compareVideoInput.value = '';
            }
            
            async initMediaPipe() {
                this.pose = new Pose({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                    }
                });
                
                this.pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.pose.onResults((results) => this.onPoseResults(results));
            }
            
            handleVideoFile(file) {
                if (!file.type.startsWith('video/')) {
                    alert('Please select a video file');
                    return;
                }
                
                const url = URL.createObjectURL(file);
                this.videoPreview.src = url;
                
                this.videoPreview.onloadedmetadata = () => {
                    this.canvasOverlay.width = this.videoPreview.videoWidth;
                    this.canvasOverlay.height = this.videoPreview.videoHeight;
                    this.ctx = this.canvasOverlay.getContext('2d');
                    
                    this.uploadSection.style.display = 'none';
                    this.videoContainer.classList.add('visible');
                    this.videoControls.style.display = 'flex';
                    this.videoPreview.play();
                };
            }
            
            async analyzeSwing() {
                if (this.isProcessing) return;
                this.isProcessing = true;
                this.framesData = [];
                
                this.analyzeBtn.disabled = true;
                this.analyzeBtn.innerHTML = '<span class="spinner"></span>Processing...';
                this.progressContainer.classList.add('visible');
                this.videoControls.style.display = 'none';
                
                const video = this.videoPreview;
                video.pause();
                video.currentTime = 0;
                
                try {
                    // PHASE 1: Quick pre-scan to detect swing boundaries
                    this.progressText.textContent = 'Detecting swing in video...';
                    const swingBounds = await this.detectSwingBoundaries(video);
                    
                    // PHASE 2: Only analyze frames within the swing boundaries
                    const startTime = swingBounds.start;
                    const endTime = swingBounds.end;
                    const swingDuration = endTime - startTime;
                    
                    if (swingDuration < 0.5) {
                        throw new Error('Could not detect a valid swing in the video');
                    }
                    
                    const fps = 30; // Analysis framerate
                    const totalFrames = Math.floor(swingDuration * fps);
                    const frameInterval = swingDuration / totalFrames;
                    
                    let currentFrame = 0;
                    
                    this.progressText.textContent = `Analyzing swing (${totalFrames} frames)...`;
                    
                    const processFrame = async () => {
                        if (currentFrame >= totalFrames) {
                            this.finishAnalysis();
                            return;
                        }
                        
                        video.currentTime = startTime + (currentFrame * frameInterval);
                        
                        await new Promise(resolve => {
                            video.onseeked = resolve;
                        });
                        
                        await this.pose.send({ image: video });
                        
                        currentFrame++;
                        const progress = (currentFrame / totalFrames) * 100;
                        this.progressFill.style.width = `${progress}%`;
                        this.progressText.textContent = `Analyzing frame ${currentFrame} of ${totalFrames}...`;
                        
                        // Process next frame
                        setTimeout(processFrame, 50);
                    };
                    
                    await processFrame();
                } catch (error) {
                    console.error('Analysis error:', error);
                    alert('Error analyzing video: ' + error.message);
                    this.isProcessing = false;
                    this.analyzeBtn.disabled = false;
                    this.analyzeBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>Analyze Swing';
                    this.progressContainer.classList.remove('visible');
                    this.videoControls.style.display = 'flex';
                }
            }
            
            async detectSwingBoundaries(video) {
                // IMPROVED SWING DETECTION
                // Key insight: Find the ACTUAL swing by locating the peak velocity spike
                // A real swing has much higher velocity than waggles/practice movements
                
                const scanFps = 30;
                const totalScanFrames = Math.floor(video.duration * scanFps);
                const frameInterval = video.duration / totalScanFrames;
                
                console.log('=== SWING DETECTION ===');
                console.log('Scanning ' + totalScanFrames + ' frames over ' + video.duration.toFixed(1) + 's');
                
                const poseData = [];
                
                const tempPose = new Pose({
                    locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/pose/' + file
                });
                tempPose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                let tempLandmarks = null;
                tempPose.onResults((results) => {
                    tempLandmarks = results.poseLandmarks || null;
                });
                
                await tempPose.initialize();
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 480;
                tempCanvas.height = 360;
                const tempCtx = tempCanvas.getContext('2d');
                
                for (let i = 0; i < totalScanFrames; i++) {
                    video.currentTime = i * frameInterval;
                    await new Promise(resolve => { video.onseeked = resolve; });
                    
                    tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                    tempLandmarks = null;
                    await tempPose.send({ image: tempCanvas });
                    
                    if (tempLandmarks) {
                        const wristX = (tempLandmarks[15].x + tempLandmarks[16].x) / 2;
                        const wristY = (tempLandmarks[15].y + tempLandmarks[16].y) / 2;
                        const hipY = (tempLandmarks[23].y + tempLandmarks[24].y) / 2;
                        
                        poseData.push({
                            index: i,
                            time: i * frameInterval,
                            wristX, wristY, hipY
                        });
                    }
                    
                    this.progressFill.style.width = (i / totalScanFrames * 30) + '%';
                }
                
                tempPose.close();
                
                if (poseData.length < 20) {
                    console.log('Not enough pose data');
                    return { start: 0, end: video.duration };
                }
                
                // Calculate velocities
                const velocities = [];
                for (let i = 0; i < poseData.length; i++) {
                    if (i < 2 || i >= poseData.length - 2) {
                        velocities.push(0);
                        continue;
                    }
                    const prev = poseData[i - 2];
                    const next = poseData[i + 2];
                    const dt = next.time - prev.time;
                    if (dt <= 0) {
                        velocities.push(0);
                        continue;
                    }
                    const dx = next.wristX - prev.wristX;
                    const dy = next.wristY - prev.wristY;
                    velocities.push(Math.sqrt(dx * dx + dy * dy) / dt);
                }
                
                // Smooth velocities
                const smoothVel = [];
                for (let i = 0; i < velocities.length; i++) {
                    let sum = 0, count = 0;
                    for (let j = Math.max(0, i - 2); j <= Math.min(velocities.length - 1, i + 2); j++) {
                        sum += velocities[j];
                        count++;
                    }
                    smoothVel.push(sum / count);
                }
                
                // Find PEAK velocity = DOWNSWING (not impact!)
                // Real IMPACT has a velocity DIP because club decelerates when hitting ball
                const maxVel = Math.max(...smoothVel);
                const avgVel = smoothVel.reduce((a, b) => a + b, 0) / smoothVel.length;
                
                // Find the highest velocity peak in the first 85% of the video
                // This avoids detecting motion at the very end (post-swing waggles)
                // but allows for videos with long pre-shot routines
                const searchEndIdx = Math.floor(poseData.length * 0.85);
                let peakVelIdx = 0;
                let foundPeakVel = 0;
                
                // Find highest peak in first 85% of video
                for (let i = 5; i < searchEndIdx; i++) {
                    if (smoothVel[i] > foundPeakVel) {
                        foundPeakVel = smoothVel[i];
                        peakVelIdx = i;
                    }
                }
                
                // If the peak is very low, fall back to overall max
                if (foundPeakVel < maxVel * 0.5) {
                    peakVelIdx = smoothVel.indexOf(maxVel);
                    console.log('Warning: Using overall max velocity (weak peak in first 85%)');
                }
                
                console.log('Peak velocity: ' + smoothVel[peakVelIdx].toFixed(4) + ' at ' + poseData[peakVelIdx].time.toFixed(2) + 's (downswing)');
                
                // Find TOP: The transition point right before downswing begins
                // Strategy: work BACKWARDS from peak velocity to find where velocity starts increasing
                // The TOP is the last low-velocity frame before the downswing acceleration
                
                const downswingThreshold = smoothVel[peakVelIdx] * 0.4; // 40% of peak = significant movement
                let downswingStartIdx = peakVelIdx;
                
                // Work backwards from peak to find where significant movement started
                for (let i = peakVelIdx - 1; i >= 5; i--) {
                    if (smoothVel[i] < downswingThreshold) {
                        downswingStartIdx = i + 1; // Downswing starts at next frame
                        break;
                    }
                }
                
                // TOP is 1-2 frames before downswing starts (the transition/pause point)
                let topIdx = Math.max(0, downswingStartIdx - 2);
                
                // Fine-tune: find the actual minimum velocity in a small window around this point
                const topSearchStart = Math.max(0, topIdx - 3);
                const topSearchEnd = Math.min(poseData.length - 1, topIdx + 3);
                let minVel = Infinity;
                for (let i = topSearchStart; i <= topSearchEnd; i++) {
                    if (smoothVel[i] < minVel) {
                        minVel = smoothVel[i];
                        topIdx = i;
                    }
                }
                
                console.log('TOP: ' + poseData[topIdx].time.toFixed(2) + 's (vel=' + minVel.toFixed(3) + ')');
                
                // Find IMPACT: hands at lowest point (minimum wristY) after peak velocity
                // This is position-based and more reliable than velocity alone
                // At impact, hands MUST be at their lowest point (physics of the swing)
                let impactIdx = peakVelIdx + 1;
                let minWristYAfterPeak = poseData[peakVelIdx].wristY;
                
                // Search from peak to 0.15s after peak
                const impactSearchEnd = Math.min(poseData.length - 1, peakVelIdx + Math.floor(scanFps * 0.15));
                
                for (let i = peakVelIdx; i <= impactSearchEnd; i++) {
                    if (poseData[i].wristY < minWristYAfterPeak) {
                        minWristYAfterPeak = poseData[i].wristY;
                        impactIdx = i;
                    }
                }
                
                // Validate: if wristY didn't drop much, fall back to velocity method
                const wristYDrop = poseData[peakVelIdx].wristY - minWristYAfterPeak;
                if (wristYDrop < 0.03) {
                    // WristY method not reliable, use velocity drop
                    const impactThreshold = smoothVel[peakVelIdx] * 0.90;
                    for (let i = peakVelIdx + 1; i <= impactSearchEnd; i++) {
                        if (smoothVel[i] < impactThreshold) {
                            impactIdx = i;
                            break;
                        }
                    }
                    console.log('IMPACT (velocity): ' + poseData[impactIdx].time.toFixed(2) + 's');
                } else {
                    console.log('IMPACT (wristY): ' + poseData[impactIdx].time.toFixed(2) + 's (drop=' + wristYDrop.toFixed(3) + ')');
                }
                
                // Find ADDRESS: stable position before backswing starts
                // We want the still frame just before the takeaway begins
                let movementStartIdx = topIdx;
                const stillThreshold = avgVel * 0.5;
                
                // First, find where movement starts (working backwards from top)
                for (let i = topIdx - 1; i >= 3; i--) {
                    if (smoothVel[i] < stillThreshold && smoothVel[i - 1] < stillThreshold && smoothVel[i - 2] < stillThreshold) {
                        movementStartIdx = i;
                        break;
                    }
                }
                
                // Now go back a short distance to find the stable address position
                // Only look back 0.3s max to avoid capturing too much pre-shot routine
                let addressIdx = Math.max(0, movementStartIdx - 3);
                let minVelInSetup = Infinity;
                
                const addressSearchStart = Math.max(0, movementStartIdx - Math.floor(scanFps * 0.3));
                for (let i = addressSearchStart; i < movementStartIdx; i++) {
                    if (smoothVel[i] < minVelInSetup) {
                        minVelInSetup = smoothVel[i];
                        addressIdx = i;
                    }
                }
                
                console.log('ADDRESS: ' + poseData[addressIdx].time.toFixed(2) + 's');
                
                // Find FINISH: velocity settles after impact
                let finishIdx = Math.min(poseData.length - 1, impactIdx + Math.floor(scanFps * 0.8));
                const finishThreshold = maxVel * 0.15;
                
                for (let i = impactIdx + 5; i < poseData.length - 3; i++) {
                    if (smoothVel[i] < finishThreshold && smoothVel[i + 1] < finishThreshold && smoothVel[i + 2] < finishThreshold) {
                        finishIdx = Math.min(i + 3, poseData.length - 1);
                        break;
                    }
                }
                console.log('FINISH: ' + poseData[finishIdx].time.toFixed(2) + 's');
                
                // Calculate tempo
                const backswingTime = poseData[topIdx].time - poseData[addressIdx].time;
                const downswingTime = poseData[impactIdx].time - poseData[topIdx].time;
                
                console.log('=== SWING TIMING ===');
                console.log('Backswing: ' + backswingTime.toFixed(2) + 's');
                console.log('Downswing: ' + downswingTime.toFixed(2) + 's');
                if (downswingTime > 0.05) {
                    console.log('Tempo: ' + (backswingTime / downswingTime).toFixed(1) + ':1');
                }
                
                // Store phases
                this.preDetectedPhases = {
                    address: poseData[addressIdx].time,
                    top: poseData[topIdx].time,
                    impact: poseData[impactIdx].time,
                    finish: poseData[finishIdx].time
                };
                
                // DEBUG: Show detected times
                console.log('=== PRE-DETECTED PHASES ===');
                console.log('Address:', poseData[addressIdx].time.toFixed(2) + 's');
                console.log('Top:', poseData[topIdx].time.toFixed(2) + 's');
                console.log('Impact:', poseData[impactIdx].time.toFixed(2) + 's');
                console.log('Finish:', poseData[finishIdx].time.toFixed(2) + 's');
                console.log('Impact idx:', impactIdx, 'Finish idx:', finishIdx, 'Same?', impactIdx === finishIdx);
                
                const startTime = Math.max(0, poseData[addressIdx].time - 0.1);
                const endTime = Math.min(video.duration, poseData[finishIdx].time + 0.2);
                
                return { start: startTime, end: endTime };
            }
            
            onPoseResults(results) {
                if (results.poseLandmarks) {
                    this.framesData.push({
                        frameNumber: this.framesData.length,
                        landmarks: results.poseLandmarks,
                        timestamp: this.videoPreview.currentTime
                    });
                }
            }
            
            finishAnalysis() {
                this.isProcessing = false;
                this.progressText.textContent = 'Detecting key positions...';
                
                // Note: Swing boundaries already detected in analyzeSwing, no need to trim
                
                // Detect key frames
                this.detectKeyFrames();
                
                // Calculate crop region if enabled
                if (this.autoCropEnabled) {
                    this.cropRegion = this.calculateCropRegion(this.framesData);
                }
                
                // Generate tips
                const tips = this.generateTips();
                const measurements = this.calculateMeasurements();
                
                // Render results
                this.renderKeyFrames();
                this.renderTips(tips);
                this.renderMeasurements(measurements);
                this.renderSwingStats(measurements);
                
                // Note: initReplay is called at the end of renderKeyFrames to avoid race conditions
                
                // Show results
                this.progressContainer.classList.remove('visible');
                this.videoContainer.classList.remove('visible');
                this.resultsSection.classList.add('visible');
                this.resultsSection.classList.add('fade-in');
            }
            
            trimToSwing() {
                const frames = this.framesData;
                if (frames.length < 20) return;
                
                // Calculate wrist speeds to detect movement
                const wristSpeeds = frames.map((frame, i) => {
                    if (i < 2 || i >= frames.length - 2) return 0;
                    
                    const prev = frames[i - 2].landmarks;
                    const next = frames[i + 2].landmarks;
                    
                    const prevWrist = this.getWristPosition(prev);
                    const nextWrist = this.getWristPosition(next);
                    
                    return Math.sqrt(
                        Math.pow(nextWrist.x - prevWrist.x, 2) + 
                        Math.pow(nextWrist.y - prevWrist.y, 2)
                    );
                });
                
                // Find swing start: first significant movement after stillness
                let swingStart = 0;
                const movementThreshold = 0.015;
                const stillnessThreshold = 0.008;
                
                // Look for period of stillness followed by movement
                for (let i = 5; i < frames.length / 2; i++) {
                    // Check if previous frames were still
                    const wasStill = wristSpeeds.slice(Math.max(0, i - 5), i).every(s => s < stillnessThreshold);
                    // Check if movement starts
                    const movementStarts = wristSpeeds[i] > movementThreshold;
                    
                    if (wasStill && movementStarts) {
                        // Back up a few frames to include the setup
                        swingStart = Math.max(0, i - 8);
                        break;
                    }
                }
                
                // Find swing end: stillness after impact (finish position held)
                let swingEnd = frames.length - 1;
                
                // First find the peak speed (around impact)
                let peakSpeedIdx = 0;
                let peakSpeed = 0;
                for (let i = Math.floor(frames.length * 0.3); i < frames.length - 5; i++) {
                    if (wristSpeeds[i] > peakSpeed) {
                        peakSpeed = wristSpeeds[i];
                        peakSpeedIdx = i;
                    }
                }
                
                // Then find where movement stops after peak (finish)
                for (let i = peakSpeedIdx + 5; i < frames.length - 3; i++) {
                    // Check for sustained stillness (finish position)
                    const isStill = wristSpeeds.slice(i, Math.min(i + 8, frames.length)).every(s => s < stillnessThreshold);
                    
                    if (isStill) {
                        // Add a few frames to show the held finish
                        swingEnd = Math.min(frames.length - 1, i + 10);
                        break;
                    }
                }
                
                // Trim the frames array
                if (swingStart > 0 || swingEnd < frames.length - 1) {
                    console.log(`Trimming video: frames ${swingStart} to ${swingEnd} (of ${frames.length})`);
                    this.framesData = frames.slice(swingStart, swingEnd + 1);
                    
                    // Re-index frame numbers
                    this.framesData.forEach((frame, i) => {
                        frame.frameNumber = i;
                    });
                }
            }
            
            detectKeyFrames() {
                const frames = this.framesData;
                if (frames.length < 10) return;
                
                // If we have pre-detected phases from boundary detection, use them directly
                if (this.preDetectedPhases) {
                    console.log('Using pre-detected phases from boundary scan');
                    console.log('Pre-detected times:', JSON.stringify(this.preDetectedPhases));
                    console.log('Total frames captured:', frames.length);
                    console.log('Frame timestamps range:', frames[0]?.timestamp?.toFixed(2), 'to', frames[frames.length-1]?.timestamp?.toFixed(2));
                    
                    // Find closest frame to each pre-detected timestamp
                    const findClosestFrame = (targetTime) => {
                        let closestIdx = 0;
                        let minDiff = Infinity;
                        for (let i = 0; i < frames.length; i++) {
                            const diff = Math.abs(frames[i].timestamp - targetTime);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestIdx = i;
                            }
                        }
                        console.log(`  Finding frame for ${targetTime.toFixed(2)}s -> frame ${closestIdx} @ ${frames[closestIdx].timestamp.toFixed(2)}s (diff: ${minDiff.toFixed(3)}s)`);
                        return closestIdx;
                    };
                    
                    const addressIdx = findClosestFrame(this.preDetectedPhases.address);
                    const topIdx = findClosestFrame(this.preDetectedPhases.top);
                    const impactIdx = findClosestFrame(this.preDetectedPhases.impact);
                    const finishIdx = findClosestFrame(this.preDetectedPhases.finish);
                    
                    console.log('Key frames from pre-detection:');
                    console.log(`  Address: frame ${addressIdx} @ ${frames[addressIdx].timestamp.toFixed(2)}s`);
                    console.log(`  Top: frame ${topIdx} @ ${frames[topIdx].timestamp.toFixed(2)}s`);
                    console.log(`  Impact: frame ${impactIdx} @ ${frames[impactIdx].timestamp.toFixed(2)}s`);
                    console.log(`  Finish: frame ${finishIdx} @ ${frames[finishIdx].timestamp.toFixed(2)}s`);
                    
                    // Calculate tempo
                    const backswingTime = frames[topIdx].timestamp - frames[addressIdx].timestamp;
                    const downswingTime = frames[impactIdx].timestamp - frames[topIdx].timestamp;
                    if (downswingTime > 0) {
                        const tempo = backswingTime / downswingTime;
                        console.log(`  Tempo: ${backswingTime.toFixed(2)}s / ${downswingTime.toFixed(2)}s = ${tempo.toFixed(1)}:1`);
                    }
                    
                    // Store original impact index for manual adjustment
                    this.originalImpactIdx = impactIdx;
                    this.impactOffset = 0;
                    
                    // Reset adjustment display
                    const display = document.getElementById('impactOffsetDisplay');
                    if (display) {
                        display.textContent = '0';
                        display.style.color = 'var(--accent-green)';
                    }
                    
                    this.keyFrames = {
                        address: frames[addressIdx],
                        top: frames[topIdx],
                        impact: frames[impactIdx],
                        finish: frames[finishIdx]
                    };
                    
                    // Clear pre-detected phases
                    this.preDetectedPhases = null;
                    return;
                }
                
                // Fallback: Calculate from scratch if no pre-detected phases
                console.log('No pre-detected phases, calculating from scratch');
                
                // Calculate wrist Y position for each frame (smoothed)
                const wristYValues = frames.map(frame => {
                    const wrist = this.getWristPosition(frame.landmarks);
                    return wrist.y;
                });
                
                // Smooth the data
                const smoothed = [];
                for (let i = 0; i < wristYValues.length; i++) {
                    let sum = 0;
                    let count = 0;
                    for (let j = Math.max(0, i - 2); j <= Math.min(wristYValues.length - 1, i + 2); j++) {
                        sum += wristYValues[j];
                        count++;
                    }
                    smoothed.push(sum / count);
                }
                
                // Find TOP: minimum wristY (highest position) in first 60%
                let topIdx = 0;
                let minY = 1;
                const topSearchEnd = Math.floor(frames.length * 0.6);
                for (let i = 3; i < topSearchEnd; i++) {
                    if (smoothed[i] < minY) {
                        minY = smoothed[i];
                        topIdx = i;
                    }
                }
                
                // Find ADDRESS: stable position before top
                let addressIdx = 0;
                for (let i = topIdx - 1; i >= 0; i--) {
                    if (i > 0 && Math.abs(smoothed[i] - smoothed[i-1]) < 0.015) {
                        addressIdx = Math.max(0, i - 2);
                        break;
                    }
                }
                
                // Find IMPACT: Use velocity-based detection (same as primary)
                // Calculate wrist velocities
                const wristSpeeds = frames.map((frame, i) => {
                    if (i < 2 || i >= frames.length - 2) return 0;
                    const prev = this.getWristPosition(frames[i - 2].landmarks);
                    const next = this.getWristPosition(frames[i + 2].landmarks);
                    const dt = frames[i + 2].timestamp - frames[i - 2].timestamp;
                    if (dt <= 0) return 0;
                    return Math.sqrt(Math.pow(next.x - prev.x, 2) + Math.pow(next.y - prev.y, 2)) / dt;
                });
                
                // Find peak velocity after top
                let peakIdx = topIdx + 3;
                let maxSpeed = 0;
                for (let i = topIdx + 3; i < frames.length - 3; i++) {
                    if (wristSpeeds[i] > maxSpeed) {
                        maxSpeed = wristSpeeds[i];
                        peakIdx = i;
                    }
                }
                
                // Find IMPACT: minimum wristY (hands at lowest) after peak
                let impactIdx = peakIdx;
                let minWristY = this.getWristPosition(frames[peakIdx].landmarks).y;
                const impactSearchEnd = Math.min(frames.length - 1, peakIdx + 5);
                
                for (let i = peakIdx; i <= impactSearchEnd; i++) {
                    const wristY = this.getWristPosition(frames[i].landmarks).y;
                    if (wristY < minWristY) {
                        minWristY = wristY;
                        impactIdx = i;
                    }
                }
                
                // Validate: if wristY method didn't find a clear low point, use velocity
                const wristYDrop = this.getWristPosition(frames[peakIdx].landmarks).y - minWristY;
                if (wristYDrop < 0.03) {
                    const peakSpeed = wristSpeeds[peakIdx];
                    const impactThreshold = peakSpeed * 0.90;
                    for (let i = peakIdx + 1; i <= impactSearchEnd; i++) {
                        if (wristSpeeds[i] < impactThreshold) {
                            impactIdx = i;
                            break;
                        }
                    }
                }
                
                // Find FINISH: wrists back up after impact
                let finishIdx = frames.length - 1;
                for (let i = impactIdx + 3; i < frames.length - 1; i++) {
                    // Finish when wrists are high and movement slows
                    const hip = this.getHipCenter(frames[i].landmarks);
                    if (smoothed[i] < hip.y * 0.8 && 
                        Math.abs(smoothed[i] - smoothed[i-1]) < 0.02) {
                        finishIdx = i;
                        break;
                    }
                }
                
                console.log('Key frames detected:');
                console.log(`  Address: frame ${addressIdx} @ ${frames[addressIdx].timestamp.toFixed(2)}s`);
                console.log(`  Top: frame ${topIdx} @ ${frames[topIdx].timestamp.toFixed(2)}s`);
                console.log(`  Impact: frame ${impactIdx} @ ${frames[impactIdx].timestamp.toFixed(2)}s`);
                console.log(`  Finish: frame ${finishIdx} @ ${frames[finishIdx].timestamp.toFixed(2)}s`);
                
                // Calculate tempo
                const backswingTime = frames[topIdx].timestamp - frames[addressIdx].timestamp;
                const downswingTime = frames[impactIdx].timestamp - frames[topIdx].timestamp;
                if (downswingTime > 0) {
                    const tempo = backswingTime / downswingTime;
                    console.log(`  Tempo: ${backswingTime.toFixed(2)}s / ${downswingTime.toFixed(2)}s = ${tempo.toFixed(1)}:1`);
                }
                
                // Store original impact index for manual adjustment
                this.originalImpactIdx = impactIdx;
                this.impactOffset = 0;
                
                // Reset adjustment display
                const display = document.getElementById('impactOffsetDisplay');
                if (display) {
                    display.textContent = '0';
                    display.style.color = 'var(--accent-green)';
                }
                
                this.keyFrames = {
                    address: frames[addressIdx],
                    top: frames[topIdx],
                    impact: frames[impactIdx],
                    finish: frames[finishIdx]
                };
            }
            
            getWristPosition(landmarks) {
                const left = landmarks[this.KEYPOINTS.LEFT_WRIST];
                const right = landmarks[this.KEYPOINTS.RIGHT_WRIST];
                return {
                    x: (left.x + right.x) / 2,
                    y: (left.y + right.y) / 2
                };
            }
            
            getHipCenter(landmarks) {
                const left = landmarks[this.KEYPOINTS.LEFT_HIP];
                const right = landmarks[this.KEYPOINTS.RIGHT_HIP];
                return {
                    x: (left.x + right.x) / 2,
                    y: (left.y + right.y) / 2
                };
            }
            
            getShoulderCenter(landmarks) {
                const left = landmarks[this.KEYPOINTS.LEFT_SHOULDER];
                const right = landmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                return {
                    x: (left.x + right.x) / 2,
                    y: (left.y + right.y) / 2
                };
            }
            
            calculateAngle(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Math.atan2(dy, dx) * (180 / Math.PI);
            }
            
            calculateSpineTilt(landmarks) {
                const hip = this.getHipCenter(landmarks);
                const shoulder = this.getShoulderCenter(landmarks);
                return this.calculateAngle(hip, shoulder) + 90; // Adjust to vertical reference
            }
            
            calculateShoulderTilt(landmarks) {
                const left = landmarks[this.KEYPOINTS.LEFT_SHOULDER];
                const right = landmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                return this.calculateAngle(left, right);
            }
            
            calculateHipTilt(landmarks) {
                const left = landmarks[this.KEYPOINTS.LEFT_HIP];
                const right = landmarks[this.KEYPOINTS.RIGHT_HIP];
                return this.calculateAngle(left, right);
            }
            
            generateTips() {
                const tips = [];
                const kf = this.keyFrames;
                const clubConfig = this.clubConfigs[this.clubType];
                
                if (!kf.address || !kf.top || !kf.impact || !kf.finish) {
                    tips.push({
                        category: 'Detection Issue',
                        text: 'Could not detect all swing phases clearly.',
                        detail: 'Try filming with better lighting and a cleaner background.',
                        severity: 'warning'
                    });
                    return tips;
                }
                
                // Add club-specific setup tip at the start
                tips.push({
                    category: `${clubConfig.name} Setup`,
                    text: clubConfig.tipModifiers.address,
                    detail: this.clubType === 'driver' 
                        ? 'Driver requires a wider stance and ball forward in stance for an ascending strike.'
                        : 'Iron setup promotes a descending strike with ball position varying by club length.',
                    severity: 'info',
                    priority: 4
                });
                
                if (this.cameraAngle === 'faceon') {
                    tips.push(...this.analyzeFaceOn());
                } else {
                    tips.push(...this.analyzeDTL());
                }
                
                // Add club-specific common faults check
                tips.push(...this.analyzeClubSpecificFaults());
                
                return tips;
            }
            
            analyzeClubSpecificFaults() {
                const tips = [];
                const kf = this.keyFrames;
                const clubConfig = this.clubConfigs[this.clubType];
                
                if (!kf.address || !kf.impact) return tips;
                
                const addressLandmarks = kf.address.landmarks;
                const impactLandmarks = kf.impact.landmarks;
                
                // Check for attack angle issues based on club type
                const addressHead = addressLandmarks[this.KEYPOINTS.NOSE];
                const impactHead = impactLandmarks[this.KEYPOINTS.NOSE];
                const addressHands = addressLandmarks[this.KEYPOINTS.LEFT_WRIST];
                const impactHands = impactLandmarks[this.KEYPOINTS.LEFT_WRIST];
                
                // Head movement relative to hands can indicate attack angle
                const headDropAtImpact = impactHead.y - addressHead.y;
                const handsDropAtImpact = impactHands.y - addressHands.y;
                
                if (this.clubType === 'driver') {
                    // Driver should have ascending attack - head stays back
                    if (headDropAtImpact > 0.05) {
                        tips.push({
                            category: 'Driver Specific',
                            text: 'Head moving down/forward through impact',
                            detail: clubConfig.tipModifiers.impact + ' Keep your head behind the ball to promote an upward strike.',
                            severity: 'warning',
                            priority: 2,
                            drill: 'Practice hitting off a high tee. Feel like you\'re hitting up on the ball with your head staying back.',
                            drillVideo: 'https://www.youtube.com/results?search_query=driver+hit+up+on+ball+drill'
                        });
                    }
                    
                    // Check stance width for driver
                    const leftAnkle = addressLandmarks[this.KEYPOINTS.LEFT_ANKLE];
                    const rightAnkle = addressLandmarks[this.KEYPOINTS.RIGHT_ANKLE];
                    const leftShoulder = addressLandmarks[this.KEYPOINTS.LEFT_SHOULDER];
                    const rightShoulder = addressLandmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                    const stanceWidth = Math.abs(rightAnkle.x - leftAnkle.x);
                    const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
                    
                    if (stanceWidth < shoulderWidth * 1.1) {
                        tips.push({
                            category: 'Driver Setup',
                            text: 'Stance may be too narrow for driver',
                            detail: 'Driver typically requires a wider stance (wider than shoulders) for stability and to promote a sweeping motion.',
                            severity: 'info',
                            priority: 3,
                            drill: 'Set up with your feet slightly wider than shoulder width for driver. Inside of feet should be outside of shoulders.',
                            drillVideo: 'https://www.youtube.com/results?search_query=driver+stance+width+setup'
                        });
                    }
                } else {
                    // Iron should have descending attack
                    if (headDropAtImpact < -0.03) {
                        tips.push({
                            category: 'Iron Specific',
                            text: 'Possible early extension / standing up',
                            detail: clubConfig.tipModifiers.impact + ' Maintain your spine angle through impact for crisp iron contact.',
                            severity: 'warning',
                            priority: 2,
                            drill: 'Practice half swings focusing on maintaining your posture. Feel like your chest stays over the ball through impact.',
                            drillVideo: 'https://www.youtube.com/results?search_query=iron+descending+blow+drill'
                        });
                    }
                    
                    // Check for scooping with irons
                    const leftWrist = impactLandmarks[this.KEYPOINTS.LEFT_WRIST];
                    const leftElbow = impactLandmarks[this.KEYPOINTS.LEFT_ELBOW];
                    const wristAngle = leftWrist.y - leftElbow.y;
                    
                    if (wristAngle > 0.08) {
                        tips.push({
                            category: 'Iron Specific',
                            text: 'Possible scooping motion',
                            detail: 'Your hands appear to be flipping at impact. With irons, hands should lead the clubhead through impact for a descending strike.',
                            severity: 'warning',
                            priority: 1,
                            drill: 'Practice punch shots with a shortened follow-through. Feel like your hands stay ahead of the clubhead at impact.',
                            drillVideo: 'https://www.youtube.com/results?search_query=stop+scooping+irons+drill'
                        });
                    }
                }
                
                return tips;
            }
            
            analyzeFaceOn() {
                const tips = [];
                const kf = this.keyFrames;
                const addressLandmarks = kf.address.landmarks;
                const topLandmarks = kf.top.landmarks;
                const impactLandmarks = kf.impact.landmarks;
                const finishLandmarks = kf.finish.landmarks;
                
                // ==========================================
                // SETUP/ADDRESS ANALYSIS (Priority: High)
                // ==========================================
                
                // Stance width
                const leftAnkle = addressLandmarks[this.KEYPOINTS.LEFT_ANKLE];
                const rightAnkle = addressLandmarks[this.KEYPOINTS.RIGHT_ANKLE];
                const leftShoulder = addressLandmarks[this.KEYPOINTS.LEFT_SHOULDER];
                const rightShoulder = addressLandmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                const stanceWidth = Math.abs(rightAnkle.x - leftAnkle.x);
                const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
                const stanceRatio = stanceWidth / shoulderWidth;
                
                if (stanceRatio < 0.8) {
                    tips.push({
                        category: 'Setup',
                        text: 'Stance too narrow',
                        detail: 'Your stance is narrower than your shoulders. This reduces stability and limits power. Widen to at least shoulder width for irons, slightly wider for driver.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Place alignment sticks on the ground at shoulder width and practice addressing the ball with feet just outside the sticks.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+stance+width+drill'
                    });
                } else if (stanceRatio > 1.5) {
                    tips.push({
                        category: 'Setup',
                        text: 'Stance too wide',
                        detail: 'An overly wide stance restricts hip rotation and can cause swaying. For irons, stance should be about shoulder width.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice with feet closer together to feel proper rotation, then gradually widen to shoulder width.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+stance+too+wide+fix'
                    });
                }
                
                // Knee flex at address
                const leftKnee = addressLandmarks[this.KEYPOINTS.LEFT_KNEE];
                const rightKnee = addressLandmarks[this.KEYPOINTS.RIGHT_KNEE];
                const leftHip = addressLandmarks[this.KEYPOINTS.LEFT_HIP];
                const rightHip = addressLandmarks[this.KEYPOINTS.RIGHT_HIP];
                
                const leftKneeAngle = this.calculateThreePointAngle(leftHip, leftKnee, leftAnkle);
                const rightKneeAngle = this.calculateThreePointAngle(rightHip, rightKnee, rightAnkle);
                const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;
                
                if (avgKneeAngle > 170) {
                    tips.push({
                        category: 'Setup',
                        text: 'Legs too straight at address',
                        detail: 'Your knees lack athletic flex. This creates tension and limits mobility. You should feel like an athlete ready to move.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice your setup by bouncing slightly on your toes, then settling into a stable, athletic position with soft knees.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+setup+knee+flex+athletic+posture'
                    });
                } else if (avgKneeAngle < 140) {
                    tips.push({
                        category: 'Setup',
                        text: 'Excessive knee flex',
                        detail: 'Too much knee bend can cause you to stand up during the swing. Your knees should have just a slight, athletic flex.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Stand tall, then unlock your knees just slightly. You should feel balanced and ready to move in any direction.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+posture+knee+flex+drill'
                    });
                }
                
                // Spine tilt at address (right shoulder should be slightly lower)
                const addressSpineTilt = this.calculateSpineTilt(addressLandmarks);
                const shoulderTiltAddress = rightShoulder.y - leftShoulder.y;
                
                if (shoulderTiltAddress < 0.01) {
                    tips.push({
                        category: 'Setup',
                        text: 'Shoulders too level at address',
                        detail: 'Your right shoulder should be slightly lower than your left (for right-handers) because your right hand is lower on the grip. This promotes proper spine tilt.',
                        severity: 'info',
                        priority: 3,
                        drill: 'When gripping the club, let your right shoulder naturally drop. Feel a slight tilt away from the target.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+shoulder+tilt+setup+spine+angle'
                    });
                }
                
                // Weight distribution check (hip center relative to feet)
                const addressHipCenter = this.getHipCenter(addressLandmarks);
                const stanceCenter = (leftAnkle.x + rightAnkle.x) / 2;
                const weightBias = (addressHipCenter.x - stanceCenter) / stanceWidth;
                
                if (Math.abs(weightBias) > 0.15) {
                    const direction = weightBias > 0 ? 'back foot' : 'front foot';
                    tips.push({
                        category: 'Setup',
                        text: `Weight favoring ${direction} at address`,
                        detail: 'Your weight should be roughly 50/50 at address for most shots. Starting with weight on one side can lead to balance issues throughout the swing.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice your setup by shifting weight fully left, then right, then settling into a balanced 50/50 position.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+weight+distribution+address+setup'
                    });
                }
                
                // ==========================================
                // BACKSWING ANALYSIS (Priority: High)
                // ==========================================
                
                const topHipCenter = this.getHipCenter(topLandmarks);
                const addressHead = addressLandmarks[this.KEYPOINTS.NOSE];
                const topHead = topLandmarks[this.KEYPOINTS.NOSE];
                const hipShift = topHipCenter.x - addressHipCenter.x;
                const headShift = topHead.x - addressHead.x;
                
                // Reverse pivot (critical fault)
                if (headShift < -0.03 && hipShift < -0.02) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Reverse pivot detected',
                        detail: 'Your weight is moving toward the target during the backswing instead of loading into your trail side. This is one of the most common amateur faults and severely limits power.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Practice swinging to the top and holding. You should feel 70-80% of your weight on your trail foot. Try the "step drill" - lift your lead foot at the top of the backswing.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+reverse+pivot+fix+drill'
                    });
                }
                
                // Sway (lateral hip movement)
                if (hipShift > 0.08) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Hip sway detected',
                        detail: 'Your hips are sliding laterally away from the target instead of rotating. This makes it difficult to return to the ball consistently.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Place a chair or alignment stick against your trail hip at address. During the backswing, your hip should rotate against the stick, not slide away from it.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+hip+sway+fix+drill'
                    });
                }
                
                // Shoulder turn
                const addressShoulderTilt = this.calculateShoulderTilt(addressLandmarks);
                const topShoulderTilt = this.calculateShoulderTilt(topLandmarks);
                const shoulderTurn = Math.abs(topShoulderTilt - addressShoulderTilt);
                
                if (shoulderTurn < 12) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Very limited shoulder turn',
                        detail: 'Your shoulders are barely rotating. A full shoulder turn (80-90) is essential for power and proper sequencing. Your back should face the target at the top.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Practice turning your lead shoulder under your chin. Hold a club across your chest and practice rotating until the club points at the ball.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+shoulder+turn+drill+backswing'
                    });
                } else if (shoulderTurn < 25) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Limited shoulder turn',
                        detail: 'Your shoulder turn could be fuller. More rotation creates more potential energy to unleash in the downswing.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Focus on turning your back to the target. Practice slow-motion backswings, pausing at the top to check your rotation.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+full+shoulder+turn+drill'
                    });
                }
                
                // Hip turn and X-factor
                const addressHipTilt = this.calculateHipTilt(addressLandmarks);
                const topHipTilt = this.calculateHipTilt(topLandmarks);
                const hipTurn = Math.abs(topHipTilt - addressHipTilt);
                const xFactor = shoulderTurn - hipTurn;
                
                if (hipTurn > shoulderTurn) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Hips over-rotating',
                        detail: 'Your hips are turning more than your shoulders, eliminating the stretch between upper and lower body. This "reverse X-factor" costs significant power.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Feel like your lower body resists while your upper body turns. Imagine your belt buckle staying more toward the target as your shoulders turn away.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+hip+turn+restriction+x+factor'
                    });
                } else if (xFactor < 10 && shoulderTurn > 20) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Limited X-factor',
                        detail: 'Your hips and shoulders are turning together. Creating separation (X-factor) between them stores elastic energy for a more powerful downswing.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Practice making backswings while keeping your knees flexed and stable. This restricts hip turn while allowing full shoulder rotation.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+x+factor+stretch+drill'
                    });
                }
                
                // Lead arm check at top
                const topLeftShoulder = topLandmarks[this.KEYPOINTS.LEFT_SHOULDER];
                const topLeftElbow = topLandmarks[this.KEYPOINTS.LEFT_ELBOW];
                const topLeftWrist = topLandmarks[this.KEYPOINTS.LEFT_WRIST];
                const leadArmAngle = this.calculateThreePointAngle(topLeftShoulder, topLeftElbow, topLeftWrist);
                
                if (leadArmAngle < 150) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Bent lead arm at top',
                        detail: 'Your lead arm is bending significantly at the top of the backswing. While some flex is acceptable, excessive bending reduces width and power.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice half swings focusing on keeping your lead arm extended. Feel like you\'re pushing the club away from you with your lead hand.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+straight+lead+arm+drill'
                    });
                }
                
                // Head movement during backswing
                const headVerticalMove = Math.abs(topHead.y - addressHead.y);
                if (headVerticalMove > 0.05) {
                    const direction = topHead.y > addressHead.y ? 'dipping down' : 'lifting up';
                    tips.push({
                        category: 'Backswing',
                        text: `Head ${direction} in backswing`,
                        detail: 'Your head is moving vertically during the backswing. This changes your spine angle and eye line, making consistent contact difficult.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice in front of a mirror or with your head gently touching a fixed object. Focus on rotating around a stable spine.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+head+movement+backswing+fix'
                    });
                }
                
                // ==========================================
                // TRANSITION & DOWNSWING (Priority: High)
                // ==========================================
                
                // Check sequencing - hips should lead
                const impactHipTilt = this.calculateHipTilt(impactLandmarks);
                const impactShoulderTilt = this.calculateShoulderTilt(impactLandmarks);
                const impactSeparation = Math.abs(impactHipTilt - impactShoulderTilt);
                
                if (impactSeparation < 5) {
                    tips.push({
                        category: 'Downswing',
                        text: 'Poor sequencing - body spinning together',
                        detail: 'Your hips and shoulders are arriving at impact together. Proper sequencing has the hips leading significantly, creating lag and power.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Practice the "pump drill" - make backswings and start down by bumping your hips toward the target before your shoulders move. Exaggerate the feeling.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+downswing+sequence+hip+lead+drill'
                    });
                } else if (impactSeparation < 12) {
                    tips.push({
                        category: 'Downswing',
                        text: 'Limited hip lead at impact',
                        detail: 'Your hips should be significantly more open than your shoulders at impact. This separation is key to generating clubhead speed.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Focus on starting the downswing with your lower body. Feel like your belt buckle is turning toward the target while your back stays to the target longer.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+hip+clearance+downswing+drill'
                    });
                }
                
                // Weight transfer to lead side
                const impactHipCenter = this.getHipCenter(impactLandmarks);
                const impactWeightPosition = (impactHipCenter.x - stanceCenter) / stanceWidth;
                
                if (impactWeightPosition > 0.1) {
                    tips.push({
                        category: 'Downswing',
                        text: 'Hanging back at impact',
                        detail: 'Your weight is staying on your back foot through impact. This causes thin shots, fat shots, and significant power loss.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Practice the "step through" drill - after impact, let your momentum carry your trail foot stepping toward the target. This encourages proper weight transfer.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+weight+transfer+step+through+drill'
                    });
                }
                
                // Casting / early release check
                const impactLeftElbow = impactLandmarks[this.KEYPOINTS.LEFT_ELBOW];
                const impactLeftWrist = impactLandmarks[this.KEYPOINTS.LEFT_WRIST];
                const impactRightWrist = impactLandmarks[this.KEYPOINTS.RIGHT_WRIST];
                const impactWristSeparation = Math.abs(impactLeftWrist.y - impactRightWrist.y);
                
                if (impactWristSeparation > 0.08) {
                    tips.push({
                        category: 'Downswing',
                        text: 'Possible early release (casting)',
                        detail: 'Your wrists appear to be unhinging too early, releasing the club before impact. This costs significant distance and consistency.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice the "lag drag" drill - make slow swings feeling like you\'re dragging the clubhead through impact with your hands leading. The "whoosh" should be after the ball.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+casting+early+release+fix+lag+drill'
                    });
                }
                
                // ==========================================
                // IMPACT ANALYSIS (Priority: High)
                // ==========================================
                
                // Head position at impact (should be behind ball)
                const impactHead = impactLandmarks[this.KEYPOINTS.NOSE];
                if (impactHead.x < impactHipCenter.x - 0.05) {
                    tips.push({
                        category: 'Impact',
                        text: 'Head moving past the ball',
                        detail: 'Your head is moving too far toward the target at impact. Keep your head behind the ball to ensure solid, compressed contact.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice hitting balls with the feeling that you\'re watching the ball with your trail eye. Your head should stay back and rotate, not slide.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+head+behind+ball+impact+drill'
                    });
                }
                
                // Lead arm extension at impact
                const impactLeftShoulder = impactLandmarks[this.KEYPOINTS.LEFT_SHOULDER];
                const impactLeadArmAngle = this.calculateThreePointAngle(impactLeftShoulder, impactLeftElbow, impactLeftWrist);
                
                if (impactLeadArmAngle < 155) {
                    tips.push({
                        category: 'Impact',
                        text: 'Chicken wing at impact',
                        detail: 'Your lead arm is bent at impact, reducing extension and power. The lead arm should be relatively straight through the hitting zone.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice hitting balls with a glove or headcover under your lead armpit. It should fall out after impact, not before - this promotes extension.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+chicken+wing+fix+drill'
                    });
                }
                
                // ==========================================
                // FINISH ANALYSIS (Priority: Medium)
                // ==========================================
                
                // Weight transfer completion
                const finishHipCenter = this.getHipCenter(finishLandmarks);
                const finishLeftAnkle = finishLandmarks[this.KEYPOINTS.LEFT_ANKLE];
                
                if (finishHipCenter.x > finishLeftAnkle.x + 0.03) {
                    tips.push({
                        category: 'Finish',
                        text: 'Incomplete weight transfer',
                        detail: 'Your weight hasn\'t fully transferred to your lead leg at the finish. A proper finish has 90%+ of weight on the lead foot.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Practice holding your finish for 3 seconds. You should be able to lift your trail foot off the ground and balance on your lead leg.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+weight+transfer+finish+balance+drill'
                    });
                }
                
                // Balance check at finish
                const finishHead = finishLandmarks[this.KEYPOINTS.NOSE];
                const finishShoulderCenter = this.getShoulderCenter(finishLandmarks);
                const finishSpineAngle = Math.abs(finishHead.x - finishHipCenter.x);
                
                if (finishSpineAngle > 0.12) {
                    tips.push({
                        category: 'Finish',
                        text: 'Reverse C finish position',
                        detail: 'You\'re finishing with excessive backward lean. This "reverse C" puts stress on your lower back and often indicates early extension.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice finishing tall with your chest facing the target. Your spine should be relatively straight, not arched backward.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+reverse+c+finish+fix+early+extension'
                    });
                }
                
                // Full rotation check
                const finishShoulderTilt = this.calculateShoulderTilt(finishLandmarks);
                const finishRotation = Math.abs(finishShoulderTilt - addressShoulderTilt);
                
                if (finishRotation < 40) {
                    tips.push({
                        category: 'Finish',
                        text: 'Incomplete rotation in finish',
                        detail: 'Your body hasn\'t fully rotated through to the finish. This often indicates deceleration or blocking through impact.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Practice swinging to a full finish where your belt buckle faces the target and your trail shoulder points at the target. Hold for 3 seconds.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+full+finish+rotation+drill'
                    });
                }
                
                // Trail foot position (should be on toe)
                const finishRightAnkle = finishLandmarks[this.KEYPOINTS.RIGHT_ANKLE];
                const finishRightKnee = finishLandmarks[this.KEYPOINTS.RIGHT_KNEE];
                const finishRightHip = finishLandmarks[this.KEYPOINTS.RIGHT_HIP];
                
                if (finishRightAnkle.y < finishRightKnee.y - 0.1) {
                    // Trail foot appears grounded
                    tips.push({
                        category: 'Finish',
                        text: 'Trail foot flat at finish',
                        detail: 'Your trail foot should be up on its toe at the finish, indicating full rotation and weight transfer. A flat trail foot suggests restricted hip rotation.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Practice finishing with your trail foot completely vertical, balanced on the toe. This encourages proper hip clearance.',
                        drillVideo: 'https://www.youtube.com/results?search_query=golf+finish+position+trail+foot+toe+drill'
                    });
                }
                
                // ==========================================
                // TEMPO ANALYSIS (Priority: Medium)
                // ==========================================
                
                // Calculate backswing vs downswing duration
                if (kf.address.timestamp && kf.top.timestamp && kf.impact.timestamp) {
                    const backswingTime = kf.top.timestamp - kf.address.timestamp;
                    const downswingTime = kf.impact.timestamp - kf.top.timestamp;
                    
                    if (backswingTime > 0 && downswingTime > 0) {
                        const tempoRatio = backswingTime / downswingTime;
                        
                        if (tempoRatio < 2) {
                            tips.push({
                                category: 'Tempo',
                                text: 'Rushed backswing',
                                detail: 'Your backswing is too quick relative to your downswing. Ideal tempo is about 3:1 (backswing:downswing). A rushed backswing leads to poor positions.',
                                severity: 'warning',
                                priority: 2,
                                drill: 'Practice with a metronome or count "one-two" (back) and "three" (through). The backswing should feel smooth and unhurried.',
                                drillVideo: 'https://www.youtube.com/results?search_query=golf+tempo+drill+backswing+too+fast'
                            });
                        } else if (tempoRatio > 5) {
                            tips.push({
                                category: 'Tempo',
                                text: 'Deceleration in downswing',
                                detail: 'Your downswing appears slower than expected. You should accelerate through the ball, not decelerate.',
                                severity: 'warning',
                                priority: 2,
                                drill: 'Make practice swings where you focus on the "whoosh" sound being loudest after where the ball would be, not before.',
                                drillVideo: 'https://www.youtube.com/results?search_query=golf+accelerate+through+impact+drill'
                            });
                        }
                    }
                }
                
                // ==========================================
                // POSITIVE FEEDBACK
                // ==========================================
                
                // Add positive observations
                const positives = [];
                
                if (stanceRatio >= 0.9 && stanceRatio <= 1.3) {
                    positives.push('Good stance width');
                }
                if (shoulderTurn >= 25) {
                    positives.push('Solid shoulder turn');
                }
                if (impactSeparation >= 12) {
                    positives.push('Good hip-shoulder separation');
                }
                if (Math.abs(hipShift) <= 0.05) {
                    positives.push('Stable lower body in backswing');
                }
                if (impactWeightPosition <= 0) {
                    positives.push('Good weight shift to lead side');
                }
                
                if (positives.length > 0 && tips.length > 0) {
                    tips.push({
                        category: 'Strengths',
                        text: 'What you\'re doing well',
                        detail: positives.join('  '),
                        severity: 'success',
                        priority: 10
                    });
                }
                
                // If no issues found
                if (tips.length === 0) {
                    tips.push({
                        category: 'Overall',
                        text: 'Excellent swing fundamentals!',
                        detail: 'No significant issues detected from this angle. Your positions look solid throughout the swing. Consider filming down-the-line for additional analysis of your swing plane.',
                        severity: 'success',
                        priority: 10
                    });
                }
                
                // Sort by priority (lower number = higher priority)
                tips.sort((a, b) => (a.priority || 5) - (b.priority || 5));
                
                return tips;
            }
            
            // Helper function to calculate angle between three points
            calculateThreePointAngle(p1, p2, p3) {
                const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
                const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
                
                const dot = v1.x * v2.x + v1.y * v2.y;
                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                
                if (mag1 === 0 || mag2 === 0) return 180;
                
                const cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
                return Math.acos(cosAngle) * (180 / Math.PI);
            }
            
            analyzeDTL() {
                const tips = [];
                const kf = this.keyFrames;
                const addressLandmarks = kf.address.landmarks;
                const topLandmarks = kf.top.landmarks;
                const impactLandmarks = kf.impact.landmarks;
                const finishLandmarks = kf.finish.landmarks;
                
                // ==========================================
                // SETUP/ADDRESS ANALYSIS (DTL View)
                // ==========================================
                
                // Spine angle at address
                const addressSpineAngle = this.calculateSpineTilt(addressLandmarks);
                const addressHipCenter = this.getHipCenter(addressLandmarks);
                const addressShoulderCenter = this.getShoulderCenter(addressLandmarks);
                const addressHead = addressLandmarks[this.KEYPOINTS.NOSE];
                
                // Check for proper hip hinge (spine should be tilted forward)
                if (Math.abs(addressSpineAngle) < 20) {
                    tips.push({
                        category: 'Setup',
                        text: 'Insufficient forward bend',
                        detail: 'You appear too upright at address. A proper setup requires bending from the hips (not the waist) to create space for your arms to swing.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice your setup by standing tall, then pushing your hips back like you\'re closing a car door with your rear. Your weight should feel in your heels.'
                    });
                } else if (Math.abs(addressSpineAngle) > 45) {
                    tips.push({
                        category: 'Setup',
                        text: 'Too much forward bend',
                        detail: 'You\'re bent over too far at address. This restricts rotation and can cause balance issues throughout the swing.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Stand closer to the ball and let your arms hang naturally. You should feel athletic and balanced, not reaching.'
                    });
                }
                
                // Knee flex check (from DTL, looking at knee-ankle alignment)
                const leftKnee = addressLandmarks[this.KEYPOINTS.LEFT_KNEE];
                const leftAnkle = addressLandmarks[this.KEYPOINTS.LEFT_ANKLE];
                const rightKnee = addressLandmarks[this.KEYPOINTS.RIGHT_KNEE];
                const rightAnkle = addressLandmarks[this.KEYPOINTS.RIGHT_ANKLE];
                
                // ==========================================
                // BACKSWING ANALYSIS (DTL View)
                // ==========================================
                
                const topHead = topLandmarks[this.KEYPOINTS.NOSE];
                const topHipCenter = this.getHipCenter(topLandmarks);
                const topShoulderCenter = this.getShoulderCenter(topLandmarks);
                
                // Head movement check (lateral and vertical)
                const headLateralMove = topHead.x - addressHead.x;
                const headVerticalMove = topHead.y - addressHead.y;
                
                if (Math.abs(headLateralMove) > 0.06) {
                    const direction = headLateralMove > 0 ? 'toward the target' : 'away from target';
                    tips.push({
                        category: 'Backswing',
                        text: `Head sliding ${direction}`,
                        detail: 'Your head is moving laterally during the backswing. While a small amount of movement is natural, excessive head slide makes consistent contact difficult.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice with a mirror behind you or have someone hold a club against your head at address. Your head should rotate, not slide.'
                    });
                }
                
                if (headVerticalMove > 0.05) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Head dipping in backswing',
                        detail: 'Your head is dropping significantly during the backswing. This changes your spine angle and can lead to fat shots and poor contact.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Focus on keeping your chin up and eyes on the ball. Imagine your head is on a shelf that stays level throughout the swing.'
                    });
                } else if (headVerticalMove < -0.05) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Head lifting in backswing',
                        detail: 'Your head is rising during the backswing. This usually indicates standing up out of your posture, leading to thin shots.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Feel like you maintain your spine angle while you rotate. Your head should stay at the same height throughout the backswing.'
                    });
                }
                
                // Hip depth maintenance (tush line)
                const hipDepthChange = topHipCenter.y - addressHipCenter.y;
                
                if (hipDepthChange < -0.04) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Losing hip depth in backswing',
                        detail: 'Your hips are moving toward the ball during the backswing. This "standing up" makes it difficult to return to a good impact position.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice with your rear end against a wall or alignment stick. Maintain contact throughout the backswing.'
                    });
                }
                
                // Shoulder plane check
                const topLeftShoulder = topLandmarks[this.KEYPOINTS.LEFT_SHOULDER];
                const topRightShoulder = topLandmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                const shoulderPlaneAngle = Math.atan2(
                    topRightShoulder.y - topLeftShoulder.y,
                    topRightShoulder.x - topLeftShoulder.x
                ) * (180 / Math.PI);
                
                // Check if lead arm is connected (not too separated from body)
                const topLeftElbow = topLandmarks[this.KEYPOINTS.LEFT_ELBOW];
                const elbowToBodyDist = Math.abs(topLeftElbow.x - topShoulderCenter.x);
                
                if (elbowToBodyDist > 0.15) {
                    tips.push({
                        category: 'Backswing',
                        text: 'Disconnected arms at top',
                        detail: 'Your arms have separated too far from your body at the top of the backswing. This "disconnection" leads to an arms-only downswing.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Practice with a glove or towel under your trail armpit. It should stay in place at the top of the backswing.'
                    });
                }
                
                // ==========================================
                // DOWNSWING ANALYSIS (DTL View)
                // ==========================================
                
                const impactHipCenter = this.getHipCenter(impactLandmarks);
                const impactHead = impactLandmarks[this.KEYPOINTS.NOSE];
                const impactShoulderCenter = this.getShoulderCenter(impactLandmarks);
                
                // Early extension (critical fault from DTL)
                const hipForwardMove = addressHipCenter.y - impactHipCenter.y;
                
                if (hipForwardMove > 0.03) {
                    tips.push({
                        category: 'Downswing',
                        text: 'Early extension detected',
                        detail: 'Your hips are thrusting toward the ball during the downswing, losing your "tush line." This is one of the most common faults and causes blocks, hooks, and inconsistent contact.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Practice with your rear end against a wall or noodle. Focus on keeping contact while rotating your hips, not thrusting them forward. Your belt buckle should turn toward the target while your rear stays back.'
                    });
                }
                
                // Spine angle maintenance (standing up through impact)
                const impactSpineAngle = this.calculateSpineTilt(impactLandmarks);
                const spineAngleChange = Math.abs(impactSpineAngle - addressSpineAngle);
                
                if (spineAngleChange > 10) {
                    if (Math.abs(impactSpineAngle) < Math.abs(addressSpineAngle)) {
                        tips.push({
                            category: 'Downswing',
                            text: 'Standing up through impact',
                            detail: 'You\'re losing your spine angle and standing up through impact. This causes thin shots and inconsistent contact.',
                            severity: 'error',
                            priority: 1,
                            drill: 'Feel like your chest stays down and covers the ball through impact. Your spine angle at impact should match your address position.'
                        });
                    } else {
                        tips.push({
                            category: 'Downswing',
                            text: 'Dipping through impact',
                            detail: 'Your spine angle is increasing (dipping) through impact. This causes fat shots and heavy contact.',
                            severity: 'warning',
                            priority: 2,
                            drill: 'Focus on rotating through the ball rather than lunging at it. Keep your head height steady.'
                        });
                    }
                }
                
                // Over-the-top / swing plane check
                const topRightElbow = topLandmarks[this.KEYPOINTS.RIGHT_ELBOW];
                const impactRightElbow = impactLandmarks[this.KEYPOINTS.RIGHT_ELBOW];
                const impactRightShoulder = impactLandmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                
                // Check if right elbow is working out (OTT) or staying connected
                const elbowPath = impactRightElbow.x - topRightElbow.x;
                
                if (elbowPath > 0.06) {
                    tips.push({
                        category: 'Downswing',
                        text: 'Over-the-top swing path',
                        detail: 'Your trail elbow is working away from your body in the downswing, causing an out-to-in swing path. This produces pulls and slices.',
                        severity: 'error',
                        priority: 1,
                        drill: 'Feel like your trail elbow drops straight down toward your trail hip at the start of the downswing. Practice the "pump drill" - start down, stop, check elbow position, then swing through.'
                    });
                }
                
                // Getting stuck (too inside)
                if (elbowPath < -0.08) {
                    tips.push({
                        category: 'Downswing',
                        text: 'Getting stuck (too far inside)',
                        detail: 'Your trail elbow is dropping too far behind you, getting "stuck." This causes pushes, blocks, and hooks as you flip the club to catch up.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Feel like your hands and arms stay more in front of your chest during the downswing. Practice half swings where you maintain the triangle of your arms and chest.'
                    });
                }
                
                // Head movement through impact
                const impactHeadMove = impactHead.y - addressHead.y;
                
                if (impactHeadMove > 0.06) {
                    tips.push({
                        category: 'Impact',
                        text: 'Head dropping through impact',
                        detail: 'Your head is dipping significantly through impact. This changes your spine angle and low point, causing inconsistent contact.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Focus on keeping your head height constant. Imagine a ceiling just above your head that you can\'t touch during the swing.'
                    });
                } else if (impactHeadMove < -0.06) {
                    tips.push({
                        category: 'Impact',
                        text: 'Head lifting through impact',
                        detail: 'Your head is coming up through impact (often called "looking up early"). This causes thin shots and topped balls.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Keep your eyes on the ball through impact. Try to see the clubhead strike the ball before looking up. The ball will tell you where it went!'
                    });
                }
                
                // ==========================================
                // IMPACT POSITION (DTL View)
                // ==========================================
                
                // Shaft lean check (hands ahead of clubhead - approximate via wrist position)
                const impactLeftWrist = impactLandmarks[this.KEYPOINTS.LEFT_WRIST];
                const impactRightWrist = impactLandmarks[this.KEYPOINTS.RIGHT_WRIST];
                
                // Check if hands are ahead of their address position (forward shaft lean)
                const handsForward = addressHipCenter.x - ((impactLeftWrist.x + impactRightWrist.x) / 2);
                
                if (handsForward < -0.02) {
                    tips.push({
                        category: 'Impact',
                        text: 'Hands behind ball at impact',
                        detail: 'Your hands appear to be behind the ball at impact (flipping). Good ball strikers have their hands ahead of the clubhead, creating shaft lean and compression.',
                        severity: 'warning',
                        priority: 2,
                        drill: 'Practice chip shots with significant shaft lean. Feel like you\'re dragging the handle through impact with your hands leading the clubhead.'
                    });
                }
                
                // ==========================================
                // FINISH ANALYSIS (DTL View)
                // ==========================================
                
                const finishHipCenter = this.getHipCenter(finishLandmarks);
                const finishShoulderCenter = this.getShoulderCenter(finishLandmarks);
                const finishHead = finishLandmarks[this.KEYPOINTS.NOSE];
                
                // Balance check
                const finishSpineAngle = this.calculateSpineTilt(finishLandmarks);
                
                if (Math.abs(finishSpineAngle) > 30) {
                    tips.push({
                        category: 'Finish',
                        text: 'Unbalanced finish position',
                        detail: 'You\'re finishing with excessive backward lean or forward bend. A balanced finish with a tall spine indicates good swing mechanics.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Practice swinging to a balanced finish where you could hold the position for 5 seconds. Your spine should be relatively vertical.'
                    });
                }
                
                // Hip clearance at finish
                const finishHipMove = finishHipCenter.y - addressHipCenter.y;
                
                if (finishHipMove < -0.05) {
                    tips.push({
                        category: 'Finish',
                        text: 'Limited hip rotation in finish',
                        detail: 'Your hips haven\'t fully cleared in the finish. Full hip rotation is essential for power and protecting your lower back.',
                        severity: 'info',
                        priority: 3,
                        drill: 'Practice rotating your belt buckle fully toward the target. Your hips should face the target or even slightly left of it at the finish.'
                    });
                }
                
                // ==========================================
                // POSITIVE FEEDBACK
                // ==========================================
                
                const positives = [];
                
                if (Math.abs(hipForwardMove) <= 0.02) {
                    positives.push('Excellent tush line maintenance');
                }
                if (spineAngleChange <= 8) {
                    positives.push('Good spine angle retention');
                }
                if (Math.abs(headLateralMove) <= 0.04 && Math.abs(headVerticalMove) <= 0.04) {
                    positives.push('Steady head position');
                }
                if (Math.abs(elbowPath) <= 0.05) {
                    positives.push('Good swing plane');
                }
                
                if (positives.length > 0 && tips.length > 0) {
                    tips.push({
                        category: 'Strengths',
                        text: 'What you\'re doing well',
                        detail: positives.join('  '),
                        severity: 'success',
                        priority: 10
                    });
                }
                
                // If no issues found
                if (tips.length === 0) {
                    tips.push({
                        category: 'Overall',
                        text: 'Excellent swing mechanics!',
                        detail: 'No significant issues detected from this angle. Your positions look solid throughout the swing. Consider filming face-on for additional analysis of weight shift and rotation.',
                        severity: 'success',
                        priority: 10
                    });
                }
                
                // Sort by priority
                tips.sort((a, b) => (a.priority || 5) - (b.priority || 5));
                
                return tips;
            }
            
            calculateMeasurements() {
                const kf = this.keyFrames;
                const measurements = {};
                
                if (kf.address && kf.top) {
                    const addressShoulderTilt = this.calculateShoulderTilt(kf.address.landmarks);
                    const topShoulderTilt = this.calculateShoulderTilt(kf.top.landmarks);
                    measurements.shoulderTurn = Math.abs(topShoulderTilt - addressShoulderTilt).toFixed(0);
                    
                    const addressHipTilt = this.calculateHipTilt(kf.address.landmarks);
                    const topHipTilt = this.calculateHipTilt(kf.top.landmarks);
                    measurements.hipTurn = Math.abs(topHipTilt - addressHipTilt).toFixed(0);
                    
                    measurements.xFactor = Math.abs(measurements.shoulderTurn - measurements.hipTurn).toFixed(0);
                }
                
                if (kf.address) {
                    measurements.spineTilt = this.calculateSpineTilt(kf.address.landmarks).toFixed(0);
                    
                    // Stance width (relative to shoulder width)
                    const leftAnkle = kf.address.landmarks[this.KEYPOINTS.LEFT_ANKLE];
                    const rightAnkle = kf.address.landmarks[this.KEYPOINTS.RIGHT_ANKLE];
                    const leftShoulder = kf.address.landmarks[this.KEYPOINTS.LEFT_SHOULDER];
                    const rightShoulder = kf.address.landmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                    const stanceWidth = Math.abs(rightAnkle.x - leftAnkle.x);
                    const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
                    if (shoulderWidth > 0) {
                        measurements.stanceWidth = stanceWidth / shoulderWidth;
                    }
                }
                
                // Head movement (address to top)
                if (kf.address && kf.top) {
                    const addressHead = kf.address.landmarks[this.KEYPOINTS.NOSE];
                    const topHead = kf.top.landmarks[this.KEYPOINTS.NOSE];
                    measurements.headMovement = Math.sqrt(
                        Math.pow(topHead.x - addressHead.x, 2) + 
                        Math.pow(topHead.y - addressHead.y, 2)
                    );
                }
                
                // Hip-shoulder separation at impact
                if (kf.impact) {
                    const impactShoulderTilt = this.calculateShoulderTilt(kf.impact.landmarks);
                    const impactHipTilt = this.calculateHipTilt(kf.impact.landmarks);
                    measurements.hipShoulderSep = Math.abs(impactShoulderTilt - impactHipTilt).toFixed(0);
                }
                
                // Lead arm angle at top
                if (kf.top) {
                    const leadShoulder = this.golferHandedness === 'right' 
                        ? kf.top.landmarks[this.KEYPOINTS.LEFT_SHOULDER]
                        : kf.top.landmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                    const leadElbow = this.golferHandedness === 'right'
                        ? kf.top.landmarks[this.KEYPOINTS.LEFT_ELBOW]
                        : kf.top.landmarks[this.KEYPOINTS.RIGHT_ELBOW];
                    const leadWrist = this.golferHandedness === 'right'
                        ? kf.top.landmarks[this.KEYPOINTS.LEFT_WRIST]
                        : kf.top.landmarks[this.KEYPOINTS.RIGHT_WRIST];
                    
                    // Calculate angle at elbow
                    const angle1 = Math.atan2(leadShoulder.y - leadElbow.y, leadShoulder.x - leadElbow.x);
                    const angle2 = Math.atan2(leadWrist.y - leadElbow.y, leadWrist.x - leadElbow.x);
                    let elbowAngle = Math.abs(angle1 - angle2) * (180 / Math.PI);
                    if (elbowAngle > 180) elbowAngle = 360 - elbowAngle;
                    measurements.leadArmAngle = Math.round(elbowAngle);
                }
                
                // Weight transfer (finish position)
                if (kf.finish) {
                    const leftAnkle = kf.finish.landmarks[this.KEYPOINTS.LEFT_ANKLE];
                    const rightAnkle = kf.finish.landmarks[this.KEYPOINTS.RIGHT_ANKLE];
                    const hipCenter = this.getHipCenter(kf.finish.landmarks);
                    
                    // Calculate how much weight is on lead foot (for right-handed, lead = left)
                    const leadAnkle = this.golferHandedness === 'right' ? leftAnkle : rightAnkle;
                    const trailAnkle = this.golferHandedness === 'right' ? rightAnkle : leftAnkle;
                    
                    const distToLead = Math.abs(hipCenter.x - leadAnkle.x);
                    const distToTrail = Math.abs(hipCenter.x - trailAnkle.x);
                    const totalDist = distToLead + distToTrail;
                    
                    if (totalDist > 0) {
                        // Weight transfer: 100% = fully on lead foot
                        measurements.weightTransfer = Math.round((distToTrail / totalDist) * 100);
                    }
                }
                
                // Spine angle maintenance check
                if (kf.address && kf.impact) {
                    const addressSpine = this.calculateSpineTilt(kf.address.landmarks);
                    const impactSpine = this.calculateSpineTilt(kf.impact.landmarks);
                    measurements.spineAngleMaintained = Math.abs(addressSpine - impactSpine) < 10;
                }
                
                // Tempo Analysis
                if (kf.address && kf.top && kf.impact && kf.finish) {
                    const backswingTime = kf.top.timestamp - kf.address.timestamp;
                    const downswingTime = kf.impact.timestamp - kf.top.timestamp;
                    const followthroughTime = kf.finish.timestamp - kf.impact.timestamp;
                    const totalTime = kf.finish.timestamp - kf.address.timestamp;
                    
                    measurements.backswingTime = backswingTime;
                    measurements.downswingTime = downswingTime;
                    measurements.followthroughTime = followthroughTime;
                    measurements.totalTime = totalTime;
                    
                    // Tempo ratio (backswing:downswing) - pros are typically 3:1
                    if (downswingTime > 0) {
                        measurements.tempoRatio = backswingTime / downswingTime;
                    }
                }
                
                return measurements;
            }
            
            adjustImpactFrame(step) {
                if (!this.framesData || this.framesData.length === 0 || this.originalImpactIdx === null) {
                    console.log('Cannot adjust impact - no frames data');
                    return;
                }
                
                // Add step to current offset (incremental)
                this.impactOffset += step;
                
                // Calculate new impact index with bounds checking
                const newImpactIdx = Math.max(0, Math.min(this.framesData.length - 1, this.originalImpactIdx + this.impactOffset));
                
                // Clamp offset if we hit bounds
                this.impactOffset = newImpactIdx - this.originalImpactIdx;
                
                // Update offset display
                const display = document.getElementById('impactOffsetDisplay');
                if (display) {
                    display.textContent = this.impactOffset >= 0 ? `+${this.impactOffset}` : this.impactOffset;
                    display.style.color = this.impactOffset === 0 ? 'var(--accent-green)' : 'var(--text-primary)';
                }
                
                // Update keyFrames
                this.keyFrames.impact = this.framesData[newImpactIdx];
                
                console.log(`Impact adjusted: offset=${this.impactOffset}, frame=${newImpactIdx}, time=${this.keyFrames.impact.timestamp.toFixed(2)}s`);
                
                // Re-render just the impact canvas
                const canvas = document.getElementById('impactCanvas');
                const ctx = canvas.getContext('2d');
                const frame = this.keyFrames.impact;
                
                canvas.width = 300;
                canvas.height = 400;
                
                this.videoPreview.currentTime = frame.timestamp;
                this.videoPreview.onseeked = () => {
                    this.drawCroppedFrame(ctx, this.videoPreview, frame.landmarks, 
                        canvas.width, canvas.height, this.cropRegion);
                    
                    if (this.referenceLinesEnabled) {
                        this.drawReferenceLines(ctx, frame.landmarks, canvas.width, canvas.height, 'impact', this.cropRegion);
                    }
                    
                    // Update tempo display
                    this.updateTempoDisplay();
                };
            }
            
            updateTempoDisplay() {
                // Recalculate and update tempo based on adjusted impact
                if (!this.keyFrames.address || !this.keyFrames.top || !this.keyFrames.impact) return;
                
                const backswingTime = this.keyFrames.top.timestamp - this.keyFrames.address.timestamp;
                const downswingTime = this.keyFrames.impact.timestamp - this.keyFrames.top.timestamp;
                
                if (downswingTime > 0) {
                    const tempo = backswingTime / downswingTime;
                    console.log(`Updated tempo: ${backswingTime.toFixed(2)}s / ${downswingTime.toFixed(2)}s = ${tempo.toFixed(1)}:1`);
                    
                    // Update tempo stat if displayed
                    const tempoStat = document.querySelector('.stat-item .stat-value');
                    if (tempoStat && tempoStat.textContent.includes(':1')) {
                        // Find the tempo stat specifically
                        document.querySelectorAll('.stat-item').forEach(item => {
                            const label = item.querySelector('.stat-label');
                            if (label && label.textContent.includes('Tempo')) {
                                const value = item.querySelector('.stat-value');
                                if (value) value.textContent = tempo.toFixed(1) + ':1';
                            }
                        });
                    }
                }
            }
            
            renderKeyFrames() {
                const phases = ['address', 'top', 'impact', 'finish'];
                const canvasIds = ['addressCanvas', 'topCanvas', 'impactCanvas', 'finishCanvas'];
                
                console.log('=== RENDERING KEY FRAMES ===');
                console.log('keyFrames object:', this.keyFrames);
                phases.forEach(p => {
                    if (this.keyFrames[p]) {
                        console.log(`  ${p}: timestamp=${this.keyFrames[p].timestamp?.toFixed(2)}s`);
                    } else {
                        console.log(`  ${p}: NOT SET`);
                    }
                });
                
                // Render frames sequentially to avoid race conditions
                const renderFrame = (index) => {
                    if (index >= phases.length) {
                        // All frames rendered, now safe to initialize replay
                        this.initReplay();
                        return;
                    }
                    
                    const phase = phases[index];
                    const canvas = document.getElementById(canvasIds[index]);
                    const ctx = canvas.getContext('2d');
                    const frame = this.keyFrames[phase];
                    
                    if (!frame) {
                        console.log(`Skipping ${phase} - no frame data`);
                        renderFrame(index + 1);
                        return;
                    }
                    
                    console.log(`Rendering ${phase} @ ${frame.timestamp?.toFixed(2)}s`);
                    
                    canvas.width = 300;
                    canvas.height = 400;
                    
                    // Seek to frame timestamp
                    this.videoPreview.currentTime = frame.timestamp;
                    
                    // Wait for seek to complete before drawing
                    this.videoPreview.onseeked = () => {
                        console.log(`Drawing ${phase} canvas - video.currentTime: ${this.videoPreview.currentTime.toFixed(2)}s, target: ${frame.timestamp?.toFixed(2)}s`);
                        
                        this.drawCroppedFrame(ctx, this.videoPreview, frame.landmarks, 
                            canvas.width, canvas.height, this.cropRegion);
                        
                        // Draw reference lines if enabled
                        if (this.referenceLinesEnabled) {
                            this.drawReferenceLines(ctx, frame.landmarks, canvas.width, canvas.height, phase, this.cropRegion);
                        }
                        
                        // Render next frame after a small delay
                        setTimeout(() => renderFrame(index + 1), 50);
                    };
                };
                
                // Start rendering from first frame
                renderFrame(0);
            }
            
            // ==========================================
            // DRAWING TOOLS METHODS
            // ==========================================
            
            openDrawingMode() {
                if (!this.keyFrames.address) {
                    alert('Please analyze a swing first');
                    return;
                }
                
                this.drawingModal.classList.add('visible');
                
                // Small delay to ensure modal is rendered before sizing canvas
                setTimeout(() => {
                    this.initDrawingCanvas();
                    this.selectDrawingFrame('address');
                }, 50);
            }
            
            closeDrawingModeModal() {
                this.drawingModal.classList.remove('visible');
            }
            
            initDrawingCanvas() {
                const container = this.drawingCanvasContainer;
                const containerRect = container.getBoundingClientRect();
                
                // Set canvas sizes based on video dimensions
                const vw = this.videoPreview.videoWidth;
                const vh = this.videoPreview.videoHeight;
                
                // Use full container size (CSS handles the positioning)
                const availableWidth = containerRect.width - 20;
                const availableHeight = containerRect.height - 20;
                
                // Calculate scale to fit
                const scale = Math.min(
                    availableWidth / vw,
                    availableHeight / vh
                );
                
                const canvasWidth = Math.floor(vw * scale);
                const canvasHeight = Math.floor(vh * scale);
                
                console.log('Canvas init:', { containerRect, vw, vh, scale, canvasWidth, canvasHeight });
                
                // Setup background canvas (for video frame)
                this.drawingCanvasBg.width = canvasWidth;
                this.drawingCanvasBg.height = canvasHeight;
                
                // Setup drawing canvas (for annotations)
                this.drawingCanvas.width = canvasWidth;
                this.drawingCanvas.height = canvasHeight;
                
                // Store dimensions
                this.drawingCanvasWidth = canvasWidth;
                this.drawingCanvasHeight = canvasHeight;
                this.drawingVideoScale = scale;
                
                // Apply zoom transform
                this.updateCanvasTransform();
                
                // Setup drawing events
                this.setupDrawingEvents();
            }
            
            updateCanvasTransform() {
                const transform = `scale(${this.drawingZoom})`;
                this.drawingCanvasBg.style.transform = transform;
                this.drawingCanvas.style.transform = transform;
                this.zoomLevelDisplay.textContent = `${Math.round(this.drawingZoom * 100)}%`;
            }
            
            setupDrawingEvents() {
                const canvas = this.drawingCanvas;
                
                // Remove old listeners if any
                canvas.onmousedown = null;
                canvas.onmousemove = null;
                canvas.onmouseup = null;
                canvas.ontouchstart = null;
                canvas.ontouchmove = null;
                canvas.ontouchend = null;
                
                // Mouse events
                canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                canvas.addEventListener('mousemove', (e) => this.draw(e));
                canvas.addEventListener('mouseup', (e) => this.endDrawing(e));
                canvas.addEventListener('mouseleave', (e) => this.endDrawing(e));
                
                // Touch events
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrawing(e.touches[0]);
                });
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.draw(e.touches[0]);
                });
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.endDrawing(e);
                });
                
                // Pan with right-click or two-finger drag
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            selectDrawingFrame(frame) {
                this.currentDrawingFrame = frame;
                
                // Update button states
                document.querySelectorAll('.frame-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.frame === frame);
                });
                
                // Draw the frame
                this.renderDrawingFrame();
            }
            
            navigateDrawingFrame(direction) {
                const frames = ['address', 'top', 'impact', 'finish'];
                const currentIndex = frames.indexOf(this.currentDrawingFrame);
                const newIndex = Math.max(0, Math.min(frames.length - 1, currentIndex + direction));
                this.selectDrawingFrame(frames[newIndex]);
            }
            
            renderDrawingFrame() {
                const frame = this.keyFrames[this.currentDrawingFrame];
                if (!frame) return;
                
                const bgCtx = this.drawingCanvasBg.getContext('2d');
                const video = this.videoPreview;
                
                // Seek to frame timestamp and draw
                video.currentTime = frame.timestamp;
                video.onseeked = () => {
                    // Draw full frame (no crop)
                    bgCtx.drawImage(
                        video, 
                        0, 0, video.videoWidth, video.videoHeight,
                        0, 0, this.drawingCanvasWidth, this.drawingCanvasHeight
                    );
                    
                    // Draw skeleton
                    this.drawSkeletonOnDrawingCanvas(bgCtx, frame.landmarks);
                    
                    // Redraw saved annotations for this frame
                    this.redrawAnnotations();
                };
            }
            
            drawSkeletonOnDrawingCanvas(ctx, landmarks) {
                const w = this.drawingCanvasWidth;
                const h = this.drawingCanvasHeight;
                
                const connections = [
                    [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
                    [11, 23], [12, 24], [23, 24], [23, 25], [25, 27], [24, 26], [26, 28]
                ];
                
                ctx.strokeStyle = 'rgba(74, 222, 128, 0.7)';
                ctx.lineWidth = 2;
                
                connections.forEach(([i, j]) => {
                    const p1 = landmarks[i];
                    const p2 = landmarks[j];
                    
                    if (p1.visibility > 0.5 && p2.visibility > 0.5) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x * w, p1.y * h);
                        ctx.lineTo(p2.x * w, p2.y * h);
                        ctx.stroke();
                    }
                });
                
                // Draw joints
                ctx.fillStyle = 'rgba(74, 222, 128, 0.9)';
                for (let i = 11; i <= 28; i++) {
                    const point = landmarks[i];
                    if (point.visibility > 0.5) {
                        ctx.beginPath();
                        ctx.arc(point.x * w, point.y * h, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            getCanvasCoordinates(e) {
                const canvas = this.drawingCanvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
            
            startDrawing(e) {
                this.isDrawing = true;
                const coords = this.getCanvasCoordinates(e);
                this.drawStart = coords;
                
                if (this.drawingTool === 'freehand') {
                    this.freehandPoints = [coords];
                }
            }
            
            draw(e) {
                if (!this.isDrawing) return;
                
                const coords = this.getCanvasCoordinates(e);
                const ctx = this.drawingCanvas.getContext('2d');
                
                // Clear and redraw annotations
                this.redrawAnnotations();
                
                // Draw current shape preview
                ctx.strokeStyle = this.drawingColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                switch (this.drawingTool) {
                    case 'line':
                        ctx.beginPath();
                        ctx.moveTo(this.drawStart.x, this.drawStart.y);
                        ctx.lineTo(coords.x, coords.y);
                        ctx.stroke();
                        break;
                        
                    case 'arrow':
                        this.drawArrow(ctx, this.drawStart.x, this.drawStart.y, coords.x, coords.y);
                        break;
                        
                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(coords.x - this.drawStart.x, 2) + 
                            Math.pow(coords.y - this.drawStart.y, 2)
                        );
                        ctx.beginPath();
                        ctx.arc(this.drawStart.x, this.drawStart.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'freehand':
                        this.freehandPoints.push(coords);
                        ctx.beginPath();
                        ctx.moveTo(this.freehandPoints[0].x, this.freehandPoints[0].y);
                        for (let i = 1; i < this.freehandPoints.length; i++) {
                            ctx.lineTo(this.freehandPoints[i].x, this.freehandPoints[i].y);
                        }
                        ctx.stroke();
                        break;
                }
            }
            
            endDrawing(e) {
                if (!this.isDrawing) return;
                this.isDrawing = false;
                
                const coords = e.clientX ? this.getCanvasCoordinates(e) : this.drawStart;
                
                // Save the drawing
                const drawing = {
                    tool: this.drawingTool,
                    color: this.drawingColor,
                    start: { ...this.drawStart },
                    end: coords
                };
                
                if (this.drawingTool === 'freehand') {
                    drawing.points = [...this.freehandPoints];
                }
                
                if (this.drawingTool === 'circle') {
                    drawing.radius = Math.sqrt(
                        Math.pow(coords.x - this.drawStart.x, 2) + 
                        Math.pow(coords.y - this.drawStart.y, 2)
                    );
                }
                
                // Only save if there's actual movement
                const dist = Math.sqrt(
                    Math.pow(coords.x - this.drawStart.x, 2) + 
                    Math.pow(coords.y - this.drawStart.y, 2)
                );
                
                if (dist > 5 || (this.drawingTool === 'freehand' && this.freehandPoints.length > 2)) {
                    this.frameDrawings[this.currentDrawingFrame].push(drawing);
                    this.drawingHistory.push({
                        frame: this.currentDrawingFrame,
                        index: this.frameDrawings[this.currentDrawingFrame].length - 1
                    });
                }
                
                this.redrawAnnotations();
            }
            
            drawArrow(ctx, fromX, fromY, toX, toY) {
                const headLength = 15;
                const angle = Math.atan2(toY - fromY, toX - fromX);
                
                // Draw line
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.stroke();
                
                // Draw arrowhead
                ctx.beginPath();
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - headLength * Math.cos(angle - Math.PI / 6),
                    toY - headLength * Math.sin(angle - Math.PI / 6)
                );
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - headLength * Math.cos(angle + Math.PI / 6),
                    toY - headLength * Math.sin(angle + Math.PI / 6)
                );
                ctx.stroke();
            }
            
            redrawAnnotations() {
                const ctx = this.drawingCanvas.getContext('2d');
                ctx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                
                const drawings = this.frameDrawings[this.currentDrawingFrame];
                
                drawings.forEach(drawing => {
                    ctx.strokeStyle = drawing.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    switch (drawing.tool) {
                        case 'line':
                            ctx.beginPath();
                            ctx.moveTo(drawing.start.x, drawing.start.y);
                            ctx.lineTo(drawing.end.x, drawing.end.y);
                            ctx.stroke();
                            break;
                            
                        case 'arrow':
                            this.drawArrow(ctx, drawing.start.x, drawing.start.y, drawing.end.x, drawing.end.y);
                            break;
                            
                        case 'circle':
                            ctx.beginPath();
                            ctx.arc(drawing.start.x, drawing.start.y, drawing.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            break;
                            
                        case 'freehand':
                            if (drawing.points && drawing.points.length > 1) {
                                ctx.beginPath();
                                ctx.moveTo(drawing.points[0].x, drawing.points[0].y);
                                for (let i = 1; i < drawing.points.length; i++) {
                                    ctx.lineTo(drawing.points[i].x, drawing.points[i].y);
                                }
                                ctx.stroke();
                            }
                            break;
                    }
                });
            }
            
            undoLastDrawing() {
                if (this.drawingHistory.length === 0) return;
                
                const lastAction = this.drawingHistory.pop();
                this.frameDrawings[lastAction.frame].pop();
                
                // If we're on the frame that was affected, redraw
                if (lastAction.frame === this.currentDrawingFrame) {
                    this.redrawAnnotations();
                }
            }
            
            clearAllDrawings() {
                this.frameDrawings[this.currentDrawingFrame] = [];
                this.redrawAnnotations();
            }
            
            adjustZoom(delta) {
                this.drawingZoom = Math.max(0.5, Math.min(3, this.drawingZoom + delta));
                this.updateCanvasTransform();
            }
            
            resetZoom() {
                this.drawingZoom = 1;
                this.drawingPan = { x: 0, y: 0 };
                this.updateCanvasTransform();
            }
            
            saveAnnotatedFrame() {
                // Create a combined canvas
                const combinedCanvas = document.createElement('canvas');
                combinedCanvas.width = this.drawingCanvasWidth;
                combinedCanvas.height = this.drawingCanvasHeight;
                const ctx = combinedCanvas.getContext('2d');
                
                // Draw background (video frame + skeleton)
                ctx.drawImage(this.drawingCanvasBg, 0, 0);
                
                // Draw annotations
                ctx.drawImage(this.drawingCanvas, 0, 0);
                
                // Add frame label
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, 120, 36);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px DM Sans, sans-serif';
                ctx.fillText(this.currentDrawingFrame.toUpperCase(), 12, 24);
                
                // Download the image
                const link = document.createElement('a');
                link.download = `swing-${this.currentDrawingFrame}-annotated.png`;
                link.href = combinedCanvas.toDataURL('image/png');
                link.click();
            }
            
            // ==========================================
            // REPLAY PLAYER METHODS
            // ==========================================
            
            initReplay() {
                if (!this.framesData || this.framesData.length === 0) return;
                
                // Reset state
                this.replayFrameIndex = 0;
                this.isPlaying = false;
                if (this.replayInterval) {
                    clearInterval(this.replayInterval);
                    this.replayInterval = null;
                }
                
                // Setup canvas
                this.replayCanvas.width = 300;
                this.replayCanvas.height = 400;
                
                // Setup scrubber
                this.replayScrubber.max = this.framesData.length - 1;
                this.replayScrubber.value = 0;
                this.replayTotalFrames.textContent = this.framesData.length - 1;
                this.replayCurrentFrame.textContent = '0';
                
                // Update play/pause button
                this.updatePlayPauseButton();
                
                // Render first frame
                this.renderReplayFrame(0);
            }
            
            updateGhostProDropdown() {
                // Update the ghost pro dropdown to show only pros with data for current club type
                const select = this.ghostProSelect;
                if (!select) return;
                
                // Clear existing options
                select.innerHTML = '';
                
                // Find pros with data for current club and camera angle
                let hasOptions = false;
                for (const [proId, proData] of Object.entries(this.proSkeletons)) {
                    const clubData = proData[this.clubType];
                    if (clubData) {
                        const viewData = this.cameraAngle === 'dtl' ? clubData.dtl : clubData.faceon;
                        if (viewData) {
                            const option = document.createElement('option');
                            option.value = proId;
                            option.textContent = `${proData.name} (${this.clubType})`;
                            select.appendChild(option);
                            hasOptions = true;
                        }
                    }
                }
                
                if (!hasOptions) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = `No ${this.clubType} swings loaded`;
                    select.appendChild(option);
                    this.selectedGhostPro = null;
                } else if (!this.selectedGhostPro || !this.proSkeletons[this.selectedGhostPro]?.[this.clubType]) {
                    // Select first available pro
                    this.selectedGhostPro = select.options[0]?.value || null;
                    select.value = this.selectedGhostPro;
                }
            }
            
            refreshCurrentView() {
                // Refresh the current view to show updated settings
                if (this.framesData && this.framesData.length > 0) {
                    this.renderReplayFrame(this.currentReplayFrame || 0);
                }
            }
            
            renderReplayFrame(index) {
                if (!this.framesData || index < 0 || index >= this.framesData.length) return;
                
                const frame = this.framesData[index];
                const ctx = this.replayCanvas.getContext('2d');
                
                // Seek video to frame timestamp
                this.videoPreview.currentTime = frame.timestamp;
                
                this.videoPreview.onseeked = () => {
                    // Draw the frame
                    this.drawCroppedFrame(ctx, this.videoPreview, frame.landmarks,
                        this.replayCanvas.width, this.replayCanvas.height, this.cropRegion);
                    
                    // Determine phase for overlays
                    const phase = this.getPhaseForFrame(index);
                    
                    // Draw ghost skeleton if enabled (draw BEFORE user skeleton for layering)
                    if (this.ghostModeEnabled) {
                        this.drawGhostSkeleton(ctx, phase, this.replayCanvas.width, this.replayCanvas.height);
                    }
                    
                    // Draw reference lines if enabled
                    if (this.referenceLinesEnabled) {
                        this.drawReferenceLines(ctx, frame.landmarks, 
                            this.replayCanvas.width, this.replayCanvas.height, phase, this.cropRegion);
                    }
                    
                    // Draw hand path if enabled
                    if (this.handPathEnabled) {
                        this.drawHandPath(ctx, index, this.replayCanvas.width, this.replayCanvas.height);
                    }
                };
                
                // Update UI
                this.replayCurrentFrame.textContent = index;
                this.replayScrubber.value = index;
            }
            
            getPhaseForFrame(index) {
                // Determine which phase this frame belongs to
                if (!this.keyFrames) return 'address';
                
                const addressIdx = this.framesData.indexOf(this.keyFrames.address);
                const topIdx = this.framesData.indexOf(this.keyFrames.top);
                const impactIdx = this.framesData.indexOf(this.keyFrames.impact);
                const finishIdx = this.framesData.indexOf(this.keyFrames.finish);
                
                if (index <= addressIdx + 2) return 'address';
                if (index <= topIdx + 2) return 'top';
                if (index <= impactIdx + 2) return 'impact';
                return 'finish';
            }
            
            drawHandPath(ctx, currentIndex, canvasWidth, canvasHeight) {
                if (!this.framesData || this.framesData.length < 2) return;
                
                // Get crop region and draw region for proper coordinate transformation
                const cropRegion = this.cropRegion;
                const drawRegion = this.lastDrawRegion;
                
                // Transform function - same as skeleton drawing
                const transform = (point) => {
                    if (drawRegion && cropRegion && this.autoCropEnabled) {
                        const cropWidth = cropRegion.maxX - cropRegion.minX;
                        const cropHeight = cropRegion.maxY - cropRegion.minY;
                        const normX = (point.x - cropRegion.minX) / cropWidth;
                        const normY = (point.y - cropRegion.minY) / cropHeight;
                        return {
                            x: drawRegion.dx + normX * drawRegion.dw,
                            y: drawRegion.dy + normY * drawRegion.dh
                        };
                    } else if (drawRegion) {
                        return {
                            x: drawRegion.dx + point.x * drawRegion.dw,
                            y: drawRegion.dy + point.y * drawRegion.dh
                        };
                    } else {
                        return {
                            x: point.x * canvasWidth,
                            y: point.y * canvasHeight
                        };
                    }
                };
                
                // Determine which wrist to track based on handedness
                // Lead hand = left for right-handed, right for left-handed
                const leadWristIdx = this.golferHandedness === 'right' 
                    ? this.KEYPOINTS.LEFT_WRIST 
                    : this.KEYPOINTS.RIGHT_WRIST;
                const trailWristIdx = this.golferHandedness === 'right' 
                    ? this.KEYPOINTS.RIGHT_WRIST 
                    : this.KEYPOINTS.LEFT_WRIST;
                
                // Collect wrist positions up to current frame
                const leadPath = [];
                const trailPath = [];
                
                const endIndex = Math.min(currentIndex, this.framesData.length - 1);
                
                for (let i = 0; i <= endIndex; i++) {
                    const frame = this.framesData[i];
                    if (!frame.landmarks) continue;
                    
                    const leadWrist = frame.landmarks[leadWristIdx];
                    const trailWrist = frame.landmarks[trailWristIdx];
                    
                    if (leadWrist && leadWrist.visibility > 0.5) {
                        const pos = transform(leadWrist);
                        leadPath.push({ x: pos.x, y: pos.y, phase: this.getPhaseForFrame(i) });
                    }
                    
                    if (trailWrist && trailWrist.visibility > 0.5) {
                        const pos = transform(trailWrist);
                        trailPath.push({ x: pos.x, y: pos.y, phase: this.getPhaseForFrame(i) });
                    }
                }
                
                // Draw lead hand path (more prominent)
                this.drawPathLine(ctx, leadPath, '#4ade80', 4, true);  // Green for lead hand
                
                // Draw trail hand path (slightly less prominent)
                this.drawPathLine(ctx, trailPath, '#60a5fa', 3, false); // Blue for trail hand
                
                // Draw current hand positions as dots
                if (leadPath.length > 0) {
                    const lastLead = leadPath[leadPath.length - 1];
                    ctx.beginPath();
                    ctx.arc(lastLead.x, lastLead.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#4ade80';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (trailPath.length > 0) {
                    const lastTrail = trailPath[trailPath.length - 1];
                    ctx.beginPath();
                    ctx.arc(lastTrail.x, lastTrail.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            drawPathLine(ctx, path, color, lineWidth, showGradient) {
                if (path.length < 2) return;
                
                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (showGradient) {
                    // Draw with fading trail effect
                    for (let i = 1; i < path.length; i++) {
                        const alpha = (i / path.length) * 0.8 + 0.2; // Fade from 0.2 to 1.0
                        ctx.beginPath();
                        ctx.moveTo(path[i - 1].x, path[i - 1].y);
                        ctx.lineTo(path[i].x, path[i].y);
                        ctx.strokeStyle = color;
                        ctx.globalAlpha = alpha;
                        ctx.lineWidth = lineWidth * (0.5 + (i / path.length) * 0.5); // Thicken towards current
                        ctx.stroke();
                    }
                } else {
                    // Simple line
                    ctx.beginPath();
                    ctx.moveTo(path[0].x, path[0].y);
                    for (let i = 1; i < path.length; i++) {
                        ctx.lineTo(path[i].x, path[i].y);
                    }
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = 0.6;
                    ctx.lineWidth = lineWidth;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Create idealized pro pose landmarks for FACE-ON view
            createProPoseFaceOn(params) {
                // Base skeleton in normalized coordinates (0-1)
                // This creates a right-handed golfer facing camera (face-on view)
                const { shoulderTurn = 0, hipTurn = 0, spineAngle = 35, armExtension = 0.95, leftArmBend = 0 } = params;
                
                // Convert angles to radians
                const shoulderRad = (shoulderTurn * Math.PI) / 180;
                const hipRad = (hipTurn * Math.PI) / 180;
                const spineRad = (spineAngle * Math.PI) / 180;
                
                // Base positions (address position, centered)
                const centerX = 0.5;
                const hipY = 0.55;
                const shoulderY = 0.35;
                const headY = 0.15;
                const kneeY = 0.72;
                const ankleY = 0.9;
                
                // Shoulder width and hip width
                const shoulderWidth = 0.15;
                const hipWidth = 0.1;
                const stanceWidth = 0.12;
                
                // Apply rotation to shoulders (in face-on, rotation appears as width change)
                const shoulderDepth = Math.cos(shoulderRad);
                const hipDepth = Math.cos(hipRad);
                
                // Create landmarks array (only key body points)
                const landmarks = new Array(33).fill(null).map(() => ({ x: 0.5, y: 0.5, visibility: 0 }));
                
                // Helper to set landmark
                const setPoint = (idx, x, y, vis = 0.9) => {
                    landmarks[idx] = { x, y, visibility: vis };
                };
                
                // Head/Face points
                setPoint(0, centerX, headY); // Nose
                
                // Shoulders (11=left, 12=right from camera's perspective)
                setPoint(11, centerX - shoulderWidth * shoulderDepth, shoulderY, 0.95);
                setPoint(12, centerX + shoulderWidth * shoulderDepth, shoulderY, 0.95);
                
                // Elbows
                const elbowY = shoulderY + 0.12;
                setPoint(13, centerX - shoulderWidth * shoulderDepth - 0.05, elbowY, 0.9);
                setPoint(14, centerX + shoulderWidth * shoulderDepth + 0.08, elbowY, 0.9);
                
                // Wrists (extended for golf grip)
                const wristY = elbowY + 0.1 * armExtension;
                const wristX = centerX + 0.05; // Slightly right of center (grip position)
                setPoint(15, wristX - 0.02, wristY, 0.9);
                setPoint(16, wristX + 0.02, wristY, 0.9);
                
                // Hips (23=left, 24=right)
                setPoint(23, centerX - hipWidth * hipDepth, hipY, 0.95);
                setPoint(24, centerX + hipWidth * hipDepth, hipY, 0.95);
                
                // Knees
                setPoint(25, centerX - stanceWidth * 0.8, kneeY, 0.9);
                setPoint(26, centerX + stanceWidth * 0.8, kneeY, 0.9);
                
                // Ankles
                setPoint(27, centerX - stanceWidth, ankleY, 0.9);
                setPoint(28, centerX + stanceWidth, ankleY, 0.9);
                
                return landmarks;
            }
            
            // Create idealized pro pose landmarks for DOWN-THE-LINE view
            createProPoseDTL(params) {
                const { 
                    hipHinge = 35,      // Forward bend angle
                    kneeFlex = 25,      // Knee bend
                    armHang = 0.9,      // How far arms hang (1 = straight down)
                    headPos = 0.5,      // Head X position (0.5 = centered)
                    armLift = 0,        // Arm lift for backswing (0-1)
                    wristCock = 0,      // Wrist cock angle at top
                    hipBump = 0,        // Hip bump toward target at impact
                    rotation = 0        // Body rotation for finish
                } = params;
                
                // Convert angles
                const hingeRad = (hipHinge * Math.PI) / 180;
                const kneeRad = (kneeFlex * Math.PI) / 180;
                
                // DTL view - golfer seen from behind, facing right (toward target)
                // X axis: left-right (target is to the right)
                // Y axis: up-down
                
                // Base positions
                const centerX = 0.45;  // Slightly left of center (golfer position)
                const groundY = 0.92;
                const hipY = 0.58;
                const shoulderY = 0.38;
                
                // Create landmarks
                const landmarks = new Array(33).fill(null).map(() => ({ x: 0.5, y: 0.5, visibility: 0 }));
                
                const setPoint = (idx, x, y, vis = 0.9) => {
                    landmarks[idx] = { x, y, visibility: vis };
                };
                
                // Apply hip hinge - shoulders move forward (right in DTL)
                const hingeOffset = Math.sin(hingeRad) * 0.15;
                
                // Head
                setPoint(0, headPos + hingeOffset * 1.2, shoulderY - 0.18);
                
                // In DTL, we see golfer from behind, so left/right are close together
                const bodyWidth = 0.08;  // Body appears narrower from behind
                
                // Shoulders (tilted forward due to hip hinge)
                const shoulderFwd = hingeOffset;
                setPoint(11, centerX - bodyWidth/2 + shoulderFwd, shoulderY, 0.95);
                setPoint(12, centerX + bodyWidth/2 + shoulderFwd, shoulderY, 0.95);
                
                // Arms - in DTL view, we see them hanging or lifted
                if (armLift > 0) {
                    // Backswing position - arms lifted
                    const elbowY = shoulderY - armLift * 0.15;
                    const elbowX = centerX + shoulderFwd + 0.05;
                    setPoint(13, elbowX - 0.02, elbowY, 0.9);
                    setPoint(14, elbowX + 0.02, elbowY, 0.9);
                    
                    // Wrists at top
                    const wristY = elbowY - 0.08;
                    setPoint(15, elbowX + 0.08, wristY, 0.9);
                    setPoint(16, elbowX + 0.1, wristY, 0.9);
                } else {
                    // Address/Impact - arms hanging
                    const elbowY = shoulderY + 0.12;
                    const armX = centerX + shoulderFwd + hingeOffset * 0.5;
                    setPoint(13, armX - 0.02, elbowY, 0.9);
                    setPoint(14, armX + 0.02, elbowY, 0.9);
                    
                    // Wrists near ball
                    const wristY = elbowY + 0.1 * armHang;
                    setPoint(15, armX + 0.06, wristY, 0.9);
                    setPoint(16, armX + 0.08, wristY, 0.9);
                }
                
                // Hips (with optional bump toward target)
                const hipX = centerX + hipBump;
                setPoint(23, hipX - bodyWidth/2, hipY, 0.95);
                setPoint(24, hipX + bodyWidth/2, hipY, 0.95);
                
                // Knees (flexed)
                const kneeY = hipY + 0.18;
                const kneeFwd = Math.sin(kneeRad) * 0.05;
                setPoint(25, hipX - bodyWidth/2 + kneeFwd, kneeY, 0.9);
                setPoint(26, hipX + bodyWidth/2 + kneeFwd, kneeY, 0.9);
                
                // Ankles
                setPoint(27, hipX - bodyWidth/2 - 0.02, groundY, 0.9);
                setPoint(28, hipX + bodyWidth/2 + 0.02, groundY, 0.9);
                
                // Apply rotation for finish
                if (rotation > 0) {
                    const rotRad = (rotation * Math.PI) / 180;
                    const rotOffset = Math.sin(rotRad) * 0.1;
                    // Shift everything toward target for rotated finish
                    [0, 11, 12, 13, 14, 15, 16].forEach(idx => {
                        if (landmarks[idx]) landmarks[idx].x += rotOffset;
                    });
                }
                
                return landmarks;
            }
            
            // Draw ghost skeleton overlay
            drawGhostSkeleton(ctx, phase, canvasWidth, canvasHeight) {
                if (!this.ghostModeEnabled) return;
                
                const proData = this.proSkeletons[this.selectedGhostPro];
                if (!proData) {
                    console.log('Ghost: No pro data for', this.selectedGhostPro);
                    return;
                }
                
                // Get club-specific data first, fall back to generic if not available
                const clubData = proData[this.clubType] || proData.driver || proData.iron;
                if (!clubData) {
                    console.log('Ghost: No club data for', this.clubType);
                    return;
                }
                
                // Get the correct view based on camera angle
                const viewData = this.cameraAngle === 'dtl' ? clubData.dtl : clubData.faceon;
                if (!viewData) {
                    console.log('Ghost: No view data for', this.cameraAngle);
                    return;
                }
                
                const proLandmarks = viewData[phase];
                if (!proLandmarks) {
                    console.log('Ghost: No landmarks for phase', phase);
                    return;
                }
                
                // Get user's current landmarks for this phase to align the ghost
                const userFrame = this.keyFrames[phase];
                if (!userFrame || !userFrame.landmarks) {
                    console.log('Ghost: No user landmarks for phase', phase);
                    return;
                }
                
                const userLandmarks = userFrame.landmarks;
                const color = proData.color;
                
                // Calculate alignment: scale and offset ghost to match user's position
                // Use hips (23, 24) as anchor points for alignment
                const userHipL = userLandmarks[23];
                const userHipR = userLandmarks[24];
                const proHipL = proLandmarks[23];
                const proHipR = proLandmarks[24];
                
                if (!userHipL || !userHipR || !proHipL || !proHipR) return;
                
                // Calculate user's hip center and width
                const userHipCenterX = (userHipL.x + userHipR.x) / 2;
                const userHipCenterY = (userHipL.y + userHipR.y) / 2;
                const userHipWidth = Math.abs(userHipR.x - userHipL.x);
                
                // Calculate pro's hip center and width
                const proHipCenterX = (proHipL.x + proHipR.x) / 2;
                const proHipCenterY = (proHipL.y + proHipR.y) / 2;
                const proHipWidth = Math.abs(proHipR.x - proHipL.x);
                
                // Also use height (from hips to shoulders) for vertical scaling
                const userShoulderY = (userLandmarks[11].y + userLandmarks[12].y) / 2;
                const proShoulderY = (proLandmarks[11].y + proLandmarks[12].y) / 2;
                const userTorsoHeight = Math.abs(userHipCenterY - userShoulderY);
                const proTorsoHeight = Math.abs(proHipCenterY - proShoulderY);
                
                // Calculate scale factors
                const scaleX = userHipWidth > 0.01 ? userHipWidth / proHipWidth : 1;
                const scaleY = proTorsoHeight > 0.01 ? userTorsoHeight / proTorsoHeight : scaleX;
                
                // Use drawRegion if available for proper canvas mapping
                const drawRegion = this.lastDrawRegion;
                const cropRegion = this.cropRegion;
                
                // Transform pro landmark to canvas coordinates, aligned to user
                const transformToCanvas = (proPoint) => {
                    // First, transform relative to pro's hip center
                    const relX = (proPoint.x - proHipCenterX) * scaleX;
                    const relY = (proPoint.y - proHipCenterY) * scaleY;
                    
                    // Then position at user's hip center
                    const alignedX = userHipCenterX + relX;
                    const alignedY = userHipCenterY + relY;
                    
                    // Now map to canvas coordinates (same as user skeleton)
                    if (drawRegion && cropRegion && this.autoCropEnabled) {
                        const cropWidth = cropRegion.maxX - cropRegion.minX;
                        const cropHeight = cropRegion.maxY - cropRegion.minY;
                        const normX = (alignedX - cropRegion.minX) / cropWidth;
                        const normY = (alignedY - cropRegion.minY) / cropHeight;
                        return {
                            x: drawRegion.dx + normX * drawRegion.dw,
                            y: drawRegion.dy + normY * drawRegion.dh
                        };
                    } else if (drawRegion) {
                        return {
                            x: drawRegion.dx + alignedX * drawRegion.dw,
                            y: drawRegion.dy + alignedY * drawRegion.dh
                        };
                    } else {
                        return {
                            x: alignedX * canvasWidth,
                            y: alignedY * canvasHeight
                        };
                    }
                };
                
                ctx.save();
                ctx.globalAlpha = 0.7;
                
                // Define skeleton connections
                const connections = [
                    [11, 12], // Shoulders
                    [11, 13], [13, 15], // Left arm
                    [12, 14], [14, 16], // Right arm
                    [11, 23], [12, 24], // Torso sides
                    [23, 24], // Hips
                    [23, 25], [25, 27], // Left leg
                    [24, 26], [26, 28], // Right leg
                ];
                
                // Draw glow effect
                ctx.shadowColor = color;
                ctx.shadowBlur = 8;
                
                // Draw connections
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                connections.forEach(([i, j]) => {
                    const p1 = proLandmarks[i];
                    const p2 = proLandmarks[j];
                    if (p1 && p2 && p1.visibility > 0.5 && p2.visibility > 0.5) {
                        const c1 = transformToCanvas(p1);
                        const c2 = transformToCanvas(p2);
                        ctx.beginPath();
                        ctx.moveTo(c1.x, c1.y);
                        ctx.lineTo(c2.x, c2.y);
                        ctx.stroke();
                    }
                });
                
                // Draw joints
                ctx.shadowBlur = 0;
                ctx.fillStyle = color;
                [11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28].forEach(idx => {
                    const point = proLandmarks[idx];
                    if (point && point.visibility > 0.5) {
                        const c = transformToCanvas(point);
                        ctx.beginPath();
                        ctx.arc(c.x, c.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Draw head position
                if (proLandmarks[0] && proLandmarks[0].visibility > 0.5) {
                    const head = transformToCanvas(proLandmarks[0]);
                    ctx.beginPath();
                    ctx.arc(head.x, head.y, 10, 0, Math.PI * 2);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            toggleReplayPlayback() {
                if (this.isPlaying) {
                    this.stopReplay();
                } else {
                    this.startReplay();
                }
            }
            
            startReplay() {
                if (!this.framesData || this.framesData.length === 0) return;
                
                this.isPlaying = true;
                this.updatePlayPauseButton();
                
                // Get speed from dropdown
                const speed = parseFloat(this.replaySpeed.value);
                // Base interval is ~30fps, adjust by speed
                const interval = Math.round((1000 / 30) / speed);
                
                this.replayInterval = setInterval(() => {
                    this.replayFrameIndex++;
                    
                    // Loop back to start
                    if (this.replayFrameIndex >= this.framesData.length) {
                        this.replayFrameIndex = 0;
                    }
                    
                    this.renderReplayFrame(this.replayFrameIndex);
                }, interval);
            }
            
            stopReplay() {
                this.isPlaying = false;
                this.updatePlayPauseButton();
                
                if (this.replayInterval) {
                    clearInterval(this.replayInterval);
                    this.replayInterval = null;
                }
            }
            
            updatePlayPauseButton() {
                const playIcon = this.replayPlayPause.querySelector('.play-icon');
                const pauseIcon = this.replayPlayPause.querySelector('.pause-icon');
                
                if (this.isPlaying) {
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'block';
                } else {
                    playIcon.style.display = 'block';
                    pauseIcon.style.display = 'none';
                }
            }
            
            replayStepFrame(delta) {
                // Stop playback if stepping manually
                if (this.isPlaying) {
                    this.stopReplay();
                }
                
                this.replayFrameIndex += delta;
                
                // Clamp to valid range
                if (this.replayFrameIndex < 0) {
                    this.replayFrameIndex = 0;
                } else if (this.replayFrameIndex >= this.framesData.length) {
                    this.replayFrameIndex = this.framesData.length - 1;
                }
                
                this.renderReplayFrame(this.replayFrameIndex);
            }
            
            replaySeekTo(frameIndex) {
                // Stop playback if scrubbing manually
                if (this.isPlaying) {
                    this.stopReplay();
                }
                
                this.replayFrameIndex = frameIndex;
                this.renderReplayFrame(this.replayFrameIndex);
            }
            
            // ==========================================
            // END REPLAY PLAYER METHODS
            // ==========================================
            
            drawReferenceLines(ctx, landmarks, width, height, phase, cropRegion) {
                // Transform landmark coordinates if cropped
                const transform = (point) => {
                    if (cropRegion && this.autoCropEnabled) {
                        const cropWidth = cropRegion.maxX - cropRegion.minX;
                        const cropHeight = cropRegion.maxY - cropRegion.minY;
                        return {
                            x: ((point.x - cropRegion.minX) / cropWidth) * width,
                            y: ((point.y - cropRegion.minY) / cropHeight) * height
                        };
                    }
                    return { x: point.x * width, y: point.y * height };
                };
                
                ctx.setLineDash([8, 4]);
                ctx.lineWidth = 2;
                
                const leftShoulder = transform(landmarks[this.KEYPOINTS.LEFT_SHOULDER]);
                const rightShoulder = transform(landmarks[this.KEYPOINTS.RIGHT_SHOULDER]);
                const leftHip = transform(landmarks[this.KEYPOINTS.LEFT_HIP]);
                const rightHip = transform(landmarks[this.KEYPOINTS.RIGHT_HIP]);
                const nose = transform(landmarks[this.KEYPOINTS.NOSE]);
                const leftAnkle = transform(landmarks[this.KEYPOINTS.LEFT_ANKLE]);
                const rightAnkle = transform(landmarks[this.KEYPOINTS.RIGHT_ANKLE]);
                
                // Calculate centers
                const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };
                const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };
                
                if (this.cameraAngle === 'faceon') {
                    // FACE-ON REFERENCE LINES
                    
                    // Vertical line through head at address (head position reference)
                    if (phase === 'address') {
                        ctx.strokeStyle = 'rgba(96, 165, 250, 0.7)'; // Blue
                        ctx.beginPath();
                        ctx.moveTo(nose.x, 0);
                        ctx.lineTo(nose.x, height);
                        ctx.stroke();
                        
                        // Store address head position for other phases
                        this.addressHeadX = nose.x;
                        this.addressHipCenterX = hipCenter.x;
                    }
                    
                    // Show address head line on other phases for comparison
                    if (phase !== 'address' && this.addressHeadX) {
                        ctx.strokeStyle = 'rgba(96, 165, 250, 0.4)'; // Faded blue
                        ctx.beginPath();
                        ctx.moveTo(this.addressHeadX, 0);
                        ctx.lineTo(this.addressHeadX, height);
                        ctx.stroke();
                    }
                    
                    // Spine angle line (hip center to shoulder center)
                    ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)'; // Yellow/amber
                    ctx.beginPath();
                    ctx.moveTo(hipCenter.x, hipCenter.y);
                    ctx.lineTo(shoulderCenter.x, shoulderCenter.y);
                    // Extend line up through head
                    const spineAngle = Math.atan2(shoulderCenter.y - hipCenter.y, shoulderCenter.x - hipCenter.x);
                    const extendedX = shoulderCenter.x + Math.cos(spineAngle) * 80;
                    const extendedY = shoulderCenter.y + Math.sin(spineAngle) * 80;
                    ctx.lineTo(extendedX, extendedY);
                    ctx.stroke();
                    
                    // Shoulder line
                    ctx.strokeStyle = 'rgba(74, 222, 128, 0.6)'; // Green
                    ctx.beginPath();
                    ctx.moveTo(leftShoulder.x - 20, leftShoulder.y);
                    ctx.lineTo(rightShoulder.x + 20, rightShoulder.y);
                    ctx.stroke();
                    
                    // Hip line
                    ctx.strokeStyle = 'rgba(248, 113, 113, 0.6)'; // Red
                    ctx.beginPath();
                    ctx.moveTo(leftHip.x - 20, leftHip.y);
                    ctx.lineTo(rightHip.x + 20, rightHip.y);
                    ctx.stroke();
                    
                    // Ground reference line at ankles
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    const groundY = Math.max(leftAnkle.y, rightAnkle.y);
                    ctx.beginPath();
                    ctx.moveTo(0, groundY);
                    ctx.lineTo(width, groundY);
                    ctx.stroke();
                    
                } else {
                    // DOWN-THE-LINE REFERENCE LINES
                    
                    // Spine angle line
                    ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)'; // Yellow/amber
                    ctx.beginPath();
                    ctx.moveTo(hipCenter.x, hipCenter.y);
                    ctx.lineTo(shoulderCenter.x, shoulderCenter.y);
                    // Extend through head
                    const spineAngle = Math.atan2(shoulderCenter.y - hipCenter.y, shoulderCenter.x - hipCenter.x);
                    const extendedX = shoulderCenter.x + Math.cos(spineAngle) * 80;
                    const extendedY = shoulderCenter.y + Math.sin(spineAngle) * 80;
                    ctx.lineTo(extendedX, extendedY);
                    ctx.stroke();
                    
                    // Tush line (vertical through hips at address)
                    if (phase === 'address') {
                        ctx.strokeStyle = 'rgba(248, 113, 113, 0.7)'; // Red
                        ctx.beginPath();
                        ctx.moveTo(hipCenter.x, 0);
                        ctx.lineTo(hipCenter.x, height);
                        ctx.stroke();
                        
                        // Store for other phases
                        this.addressTushLine = hipCenter.x;
                    }
                    
                    // Show tush line on other phases
                    if (phase !== 'address' && this.addressTushLine) {
                        ctx.strokeStyle = 'rgba(248, 113, 113, 0.4)'; // Faded red
                        ctx.beginPath();
                        ctx.moveTo(this.addressTushLine, 0);
                        ctx.lineTo(this.addressTushLine, height);
                        ctx.stroke();
                    }
                    
                    // Head position vertical line
                    ctx.strokeStyle = 'rgba(96, 165, 250, 0.6)'; // Blue
                    ctx.beginPath();
                    ctx.moveTo(nose.x, nose.y - 30);
                    ctx.lineTo(nose.x, nose.y + 50);
                    ctx.stroke();
                }
                
                // SWING PLANE LINES (for backswing and downswing phases)
                if (phase === 'top' || phase === 'impact') {
                    const leftWrist = transform(landmarks[this.KEYPOINTS.LEFT_WRIST]);
                    const rightWrist = transform(landmarks[this.KEYPOINTS.RIGHT_WRIST]);
                    const leftElbow = transform(landmarks[this.KEYPOINTS.LEFT_ELBOW]);
                    const rightElbow = transform(landmarks[this.KEYPOINTS.RIGHT_ELBOW]);
                    
                    // Estimate ball position (below and between ankles at address level)
                    const ballX = (leftAnkle.x + rightAnkle.x) / 2;
                    const ballY = Math.max(leftAnkle.y, rightAnkle.y) + 15; // Just below ankles
                    
                    // Draw swing plane from ball through hands/club
                    ctx.strokeStyle = 'rgba(168, 85, 247, 0.7)'; // Purple for swing plane
                    ctx.lineWidth = 2;
                    ctx.setLineDash([12, 6]);
                    
                    // Use the lead hand (left for right-handed) position
                    const handX = (leftWrist.x + rightWrist.x) / 2;
                    const handY = (leftWrist.y + rightWrist.y) / 2;
                    
                    // Calculate angle from ball to hands
                    const planeAngle = Math.atan2(handY - ballY, handX - ballX);
                    
                    // Extend the line through both directions
                    const extendBack = 150;
                    const extendForward = 80;
                    
                    const startX = ballX - Math.cos(planeAngle) * extendForward;
                    const startY = ballY - Math.sin(planeAngle) * extendForward;
                    const endX = handX + Math.cos(planeAngle) * extendBack;
                    const endY = handY + Math.sin(planeAngle) * extendBack;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Store address swing plane for comparison
                    if (phase === 'top') {
                        this.backswingPlaneAngle = planeAngle;
                    }
                    
                    // Show backswing plane on impact for comparison
                    if (phase === 'impact' && this.backswingPlaneAngle !== undefined) {
                        ctx.strokeStyle = 'rgba(168, 85, 247, 0.3)'; // Faded purple
                        ctx.beginPath();
                        const refStartX = ballX - Math.cos(this.backswingPlaneAngle) * extendForward;
                        const refStartY = ballY - Math.sin(this.backswingPlaneAngle) * extendForward;
                        const refEndX = ballX + Math.cos(this.backswingPlaneAngle) * 200;
                        const refEndY = ballY + Math.sin(this.backswingPlaneAngle) * 200;
                        ctx.moveTo(refStartX, refStartY);
                        ctx.lineTo(refEndX, refEndY);
                        ctx.stroke();
                    }
                }
                
                // Draw ball position indicator at address
                if (phase === 'address') {
                    // Get raw ankle landmarks (normalized 0-1)
                    const rawLeftAnkle = landmarks[this.KEYPOINTS.LEFT_ANKLE];
                    const rawRightAnkle = landmarks[this.KEYPOINTS.RIGHT_ANKLE];
                    
                    // Calculate ball position in normalized coordinates
                    let ballNormX, ballNormY;
                    const ankleNormX = (rawLeftAnkle.x + rawRightAnkle.x) / 2;
                    const ankleNormY = Math.max(rawLeftAnkle.y, rawRightAnkle.y);
                    
                    if (this.cameraAngle === 'dtl') {
                        // DTL: ball is to the right for right-handed, left for left-handed
                        // Use normalized offset (proportion of body width) - varies by club
                        const bodyWidth = Math.abs(rawRightAnkle.x - rawLeftAnkle.x);
                        const clubConfig = this.clubConfigs[this.clubType];
                        const ballOffset = bodyWidth * clubConfig.ballOffsetMultiplier;
                        
                        if (this.golferHandedness === 'right') {
                            ballNormX = ankleNormX + ballOffset;
                        } else {
                            ballNormX = ankleNormX - ballOffset;
                        }
                        ballNormY = ankleNormY + 0.02; // Slightly below ankles
                    } else {
                        // Face-on: ball position varies by club
                        // Driver: off lead heel (forward), Iron: more centered
                        const bodyWidth = Math.abs(rawRightAnkle.x - rawLeftAnkle.x);
                        const clubConfig = this.clubConfigs[this.clubType];
                        
                        if (this.clubType === 'driver') {
                            // Ball off lead heel (forward)
                            if (this.golferHandedness === 'right') {
                                ballNormX = rawLeftAnkle.x; // Lead foot for right-handed
                            } else {
                                ballNormX = rawRightAnkle.x; // Lead foot for left-handed
                            }
                        } else {
                            // Iron: center to slightly forward
                            ballNormX = ankleNormX;
                        }
                        ballNormY = ankleNormY + 0.03;
                    }
                    
                    // Transform to canvas coordinates using same transform as other elements
                    const ballPos = transform({ x: ballNormX, y: ballNormY });
                    const ballX = ballPos.x;
                    const ballY = ballPos.y;
                    
                    // Draw ball marker - more visible
                    ctx.setLineDash([]);
                    
                    // Outer glow
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(ballX, ballY, 12, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Main circle
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ballX, ballY, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner fill
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fill();
                    
                    // Store ball position for other phases (in canvas coords)
                    this.ballPosition = { x: ballX, y: ballY };
                    // Also store normalized for recalculation
                    this.ballPositionNorm = { x: ballNormX, y: ballNormY };
                }
                
                // Show ball position on other phases
                if (phase !== 'address' && this.ballPositionNorm) {
                    // Recalculate position using transform (in case canvas size differs)
                    const ballPos = transform(this.ballPositionNorm);
                    
                    ctx.setLineDash([]);
                    
                    // Dimmer version for non-address phases
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ballPos.x, ballPos.y, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fill();
                }
                
                // Reset line dash
                ctx.setLineDash([]);
            }
            
            drawSkeleton(ctx, landmarks, width, height, drawRegion) {
                // Draw connections
                const connections = [
                    [11, 12], // shoulders
                    [11, 13], [13, 15], // left arm
                    [12, 14], [14, 16], // right arm
                    [11, 23], [12, 24], // torso
                    [23, 24], // hips
                    [23, 25], [25, 27], // left leg
                    [24, 26], [26, 28], // right leg
                ];
                
                // Transform function - if drawRegion provided, use it
                const transform = (point) => {
                    if (drawRegion) {
                        return {
                            x: drawRegion.dx + point.x * drawRegion.dw,
                            y: drawRegion.dy + point.y * drawRegion.dh
                        };
                    }
                    return { x: point.x * width, y: point.y * height };
                };
                
                ctx.strokeStyle = 'rgba(74, 222, 128, 0.8)';
                ctx.lineWidth = 3;
                
                connections.forEach(([i, j]) => {
                    const p1 = landmarks[i];
                    const p2 = landmarks[j];
                    
                    if (p1.visibility > 0.5 && p2.visibility > 0.5) {
                        const t1 = transform(p1);
                        const t2 = transform(p2);
                        ctx.beginPath();
                        ctx.moveTo(t1.x, t1.y);
                        ctx.lineTo(t2.x, t2.y);
                        ctx.stroke();
                    }
                });
                
                // Draw keypoints
                ctx.fillStyle = 'rgba(163, 230, 53, 1)';
                landmarks.forEach((point, idx) => {
                    if (point.visibility > 0.5 && idx >= 11 && idx <= 28) {
                        const t = transform(point);
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
            
            renderTips(tips) {
                const container = document.getElementById('tipsContainer');
                
                if (tips.length === 0) {
                    container.innerHTML = `
                        <div class="no-issues">
                            <div class="no-issues-icon"></div>
                            <p class="no-issues-text">Looking good! No major issues detected.</p>
                        </div>
                    `;
                    return;
                }
                
                // Separate critical issues, warnings, and positives
                const critical = tips.filter(t => t.severity === 'error');
                const warnings = tips.filter(t => t.severity === 'warning');
                const info = tips.filter(t => t.severity === 'info');
                const positives = tips.filter(t => t.severity === 'success');
                
                let html = '';
                
                // Show summary count
                if (critical.length > 0 || warnings.length > 0) {
                    html += `<div class="tips-summary">
                        ${critical.length > 0 ? `<span class="summary-critical">${critical.length} critical</span>` : ''}
                        ${warnings.length > 0 ? `<span class="summary-warning">${warnings.length} to improve</span>` : ''}
                        ${info.length > 0 ? `<span class="summary-info">${info.length} minor</span>` : ''}
                    </div>`;
                }
                
                // Render critical issues first
                if (critical.length > 0) {
                    html += `<div class="tips-section-header error-header">Priority Issues</div>`;
                    html += critical.map(tip => this.renderSingleTip(tip)).join('');
                }
                
                // Then warnings
                if (warnings.length > 0) {
                    html += `<div class="tips-section-header warning-header">Areas to Improve</div>`;
                    html += warnings.map(tip => this.renderSingleTip(tip)).join('');
                }
                
                // Then info
                if (info.length > 0) {
                    html += `<div class="tips-section-header info-header">Fine-Tuning</div>`;
                    html += info.map(tip => this.renderSingleTip(tip)).join('');
                }
                
                // Positives last
                if (positives.length > 0) {
                    html += positives.map(tip => this.renderSingleTip(tip)).join('');
                }
                
                container.innerHTML = html;
            }
            
            renderSingleTip(tip) {
                const severityClass = tip.severity === 'error' ? 'error' : tip.severity === 'warning' ? 'warning' : tip.severity === 'success' ? 'success' : '';
                
                return `
                    <div class="tip-item ${severityClass}">
                        <div class="tip-header">
                            <span class="tip-category">${tip.category}</span>
                            ${tip.severity === 'error' ? '<span class="tip-badge error-badge">Fix First</span>' : ''}
                        </div>
                        <div class="tip-text">${tip.text}</div>
                        ${tip.detail ? `<div class="tip-detail">${tip.detail}</div>` : ''}
                        ${tip.drill ? `
                            <div class="tip-drill">
                                <div class="drill-header">
                                    <span class="drill-label"> Drill:</span>
                                </div>
                                <div class="drill-text">${tip.drill}</div>
                                ${tip.drillVideo ? `
                                    <a href="${tip.drillVideo}" target="_blank" rel="noopener" class="drill-video-link">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                                        </svg>
                                        Watch Drill Video
                                    </a>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            renderMeasurements(measurements) {
                const container = document.getElementById('measurementsContainer');
                
                const items = [];
                if (measurements.shoulderTurn) {
                    items.push({ value: `${measurements.shoulderTurn}`, label: 'Shoulder Turn' });
                }
                if (measurements.hipTurn) {
                    items.push({ value: `${measurements.hipTurn}`, label: 'Hip Turn' });
                }
                if (measurements.xFactor) {
                    items.push({ value: `${measurements.xFactor}`, label: 'X-Factor' });
                }
                if (measurements.spineTilt) {
                    items.push({ value: `${measurements.spineTilt}`, label: 'Spine Tilt' });
                }
                
                // Build tempo section
                let tempoHTML = '';
                if (measurements.tempoRatio) {
                    const ratio = measurements.tempoRatio;
                    const ratioDisplay = ratio.toFixed(1) + ':1';
                    
                    // Evaluate tempo (pro average is around 3:1)
                    let tempoRating, tempoClass, tempoAdvice;
                    if (ratio >= 2.5 && ratio <= 3.5) {
                        tempoRating = 'Great';
                        tempoClass = 'tempo-great';
                        tempoAdvice = 'Your tempo is in the pro range!';
                    } else if (ratio >= 2.0 && ratio < 2.5) {
                        tempoRating = 'Quick';
                        tempoClass = 'tempo-warning';
                        tempoAdvice = 'Slightly quick transition. Try a smoother takeaway.';
                    } else if (ratio > 3.5 && ratio <= 4.5) {
                        tempoRating = 'Slow';
                        tempoClass = 'tempo-warning';
                        tempoAdvice = 'Slightly slow backswing. Focus on building momentum.';
                    } else if (ratio < 2.0) {
                        tempoRating = 'Too Fast';
                        tempoClass = 'tempo-poor';
                        tempoAdvice = 'Rushing the downswing. Pause at the top.';
                    } else {
                        tempoRating = 'Too Slow';
                        tempoClass = 'tempo-poor';
                        tempoAdvice = 'Backswing is too long. Work on a more compact swing.';
                    }
                    
                    // Calculate percentages for the bar
                    const totalTime = measurements.totalTime;
                    const backPct = (measurements.backswingTime / totalTime) * 100;
                    const downPct = (measurements.downswingTime / totalTime) * 100;
                    const followPct = (measurements.followthroughTime / totalTime) * 100;
                    
                    tempoHTML = `
                        <div class="tempo-section">
                            <div class="tempo-header">
                                <span class="tempo-title"> Swing Tempo</span>
                                <span class="tempo-ratio ${tempoClass}">${ratioDisplay} <span class="tempo-rating">${tempoRating}</span></span>
                            </div>
                            
                            <div class="tempo-bar-container">
                                <div class="tempo-bar">
                                    <div class="tempo-segment tempo-backswing" style="width: ${backPct}%">
                                        <span class="tempo-segment-label">${measurements.backswingTime.toFixed(2)}s</span>
                                    </div>
                                    <div class="tempo-segment tempo-downswing" style="width: ${downPct}%">
                                        <span class="tempo-segment-label">${measurements.downswingTime.toFixed(2)}s</span>
                                    </div>
                                    <div class="tempo-segment tempo-followthrough" style="width: ${followPct}%">
                                        <span class="tempo-segment-label">${measurements.followthroughTime.toFixed(2)}s</span>
                                    </div>
                                </div>
                                <div class="tempo-labels">
                                    <span>Backswing</span>
                                    <span>Downswing</span>
                                    <span>Follow-through</span>
                                </div>
                            </div>
                            
                            <div class="tempo-advice ${tempoClass}">${tempoAdvice}</div>
                            
                            <div class="tempo-total">Total swing time: <strong>${measurements.totalTime.toFixed(2)}s</strong></div>
                        </div>
                    `;
                }
                
                if (items.length === 0 && !tempoHTML) {
                    container.style.display = 'none';
                    return;
                }
                
                const measurementsHTML = items.length > 0 ? `
                    <div class="measurements-grid">
                        ${items.map(item => `
                            <div class="measurement-item">
                                <div class="measurement-value">${item.value}</div>
                                <div class="measurement-label">${item.label}</div>
                            </div>
                        `).join('')}
                    </div>
                ` : '';
                
                container.innerHTML = measurementsHTML + tempoHTML;
            }
            
            toggleAdvancedStats() {
                this.advancedStats.classList.toggle('visible');
                this.viewMoreStatsBtn.classList.toggle('expanded');
                const btnText = this.viewMoreStatsBtn.querySelector('span');
                if (this.advancedStats.classList.contains('visible')) {
                    btnText.textContent = 'Show Less';
                } else {
                    btnText.textContent = 'View More Stats';
                }
            }
            
            renderSwingStats(measurements) {
                // Calculate swing score
                const score = this.calculateSwingScore(measurements);
                const clubConfig = this.clubConfigs[this.clubType];
                
                // Update swing score display
                const scoreValue = this.swingScoreDisplay.querySelector('.score-value');
                scoreValue.textContent = score;
                
                // Update club indicator
                const clubIndicator = this.swingScoreDisplay.querySelector('.club-indicator');
                if (clubIndicator) {
                    clubIndicator.textContent = clubConfig.name;
                }
                
                // Set score color class
                this.swingScoreDisplay.className = 'swing-score';
                if (score >= 80) {
                    this.swingScoreDisplay.classList.add('score-great');
                } else if (score >= 65) {
                    this.swingScoreDisplay.classList.add('score-good');
                } else if (score >= 50) {
                    this.swingScoreDisplay.classList.add('score-fair');
                } else {
                    this.swingScoreDisplay.classList.add('score-poor');
                }
                
                // Render basic stats (always visible)
                this.renderBasicStats(measurements);
                
                // Render advanced stats (hidden by default)
                this.renderAdvancedStats(measurements);
            }
            
            calculateSwingScore(m) {
                let score = 50; // Base score
                let factors = 0;
                const clubConfig = this.clubConfigs[this.clubType];
                const ranges = clubConfig.idealRanges;
                
                // Tempo (20 points max) - club specific
                if (m.tempoRatio) {
                    factors++;
                    const tempoIdeal = (ranges.tempo.min + ranges.tempo.max) / 2;
                    const tempoDiff = Math.abs(m.tempoRatio - tempoIdeal);
                    if (tempoDiff < 0.3) score += 20;
                    else if (tempoDiff < 0.6) score += 15;
                    else if (tempoDiff < 1.0) score += 10;
                    else if (tempoDiff < 1.5) score += 5;
                }
                
                // Shoulder turn (10 points max) - club specific
                if (m.shoulderTurn) {
                    factors++;
                    const minST = ranges.shoulderTurn.min;
                    const maxST = ranges.shoulderTurn.max;
                    if (m.shoulderTurn >= minST && m.shoulderTurn <= maxST) score += 10;
                    else if (m.shoulderTurn >= minST - 10 && m.shoulderTurn <= maxST + 10) score += 7;
                    else if (m.shoulderTurn >= minST - 25) score += 4;
                }
                
                // X-Factor (10 points max) - club specific
                if (m.xFactor) {
                    factors++;
                    const minXF = ranges.xFactor.min;
                    const maxXF = ranges.xFactor.max;
                    if (m.xFactor >= minXF && m.xFactor <= maxXF) score += 10;
                    else if (m.xFactor >= minXF - 10 && m.xFactor <= maxXF + 5) score += 7;
                    else if (m.xFactor >= minXF - 20) score += 4;
                }
                
                // Head stability (10 points max)
                if (m.headMovement !== undefined) {
                    factors++;
                    if (m.headMovement < 0.03) score += 10;
                    else if (m.headMovement < 0.05) score += 7;
                    else if (m.headMovement < 0.08) score += 4;
                }
                
                // Weight transfer (10 points max)
                if (m.weightTransfer !== undefined) {
                    factors++;
                    if (m.weightTransfer >= 85) score += 10;
                    else if (m.weightTransfer >= 70) score += 7;
                    else if (m.weightTransfer >= 50) score += 4;
                }
                
                // Normalize if we have fewer factors
                if (factors < 5 && factors > 0) {
                    score = Math.round(50 + ((score - 50) * 5 / factors));
                }
                
                return Math.min(100, Math.max(0, Math.round(score)));
            }
            
            renderBasicStats(m) {
                const stats = [];
                const clubConfig = this.clubConfigs[this.clubType];
                const ranges = clubConfig.idealRanges;
                
                // Tempo - club specific
                if (m.tempoRatio) {
                    const isGood = m.tempoRatio >= ranges.tempo.min && m.tempoRatio <= ranges.tempo.max;
                    const isWarning = (m.tempoRatio >= ranges.tempo.min - 0.5 && m.tempoRatio < ranges.tempo.min) || 
                                     (m.tempoRatio > ranges.tempo.max && m.tempoRatio <= ranges.tempo.max + 0.5);
                    stats.push({
                        label: 'Tempo',
                        value: m.tempoRatio.toFixed(1),
                        unit: ': 1',
                        range: `Ideal: ${ranges.tempo.label}`,
                        status: isGood ? 'good' : isWarning ? 'warning' : 'poor'
                    });
                }
                
                // Shoulder Turn - club specific
                if (m.shoulderTurn) {
                    const isGood = m.shoulderTurn >= ranges.shoulderTurn.min && m.shoulderTurn <= ranges.shoulderTurn.max;
                    const isWarning = m.shoulderTurn >= ranges.shoulderTurn.min - 10 && m.shoulderTurn < ranges.shoulderTurn.min;
                    stats.push({
                        label: 'Shoulder Turn',
                        value: m.shoulderTurn,
                        unit: '',
                        range: `Ideal: ${ranges.shoulderTurn.label}`,
                        status: isGood ? 'good' : isWarning ? 'warning' : 'poor'
                    });
                }
                
                // X-Factor - club specific
                if (m.xFactor) {
                    const isGood = m.xFactor >= ranges.xFactor.min && m.xFactor <= ranges.xFactor.max;
                    const isWarning = m.xFactor >= ranges.xFactor.min - 10 && m.xFactor < ranges.xFactor.min;
                    stats.push({
                        label: 'X-Factor',
                        value: m.xFactor,
                        unit: '',
                        range: `Ideal: ${ranges.xFactor.label}`,
                        status: isGood ? 'good' : isWarning ? 'warning' : 'poor'
                    });
                }
                
                // Total Swing Time
                if (m.totalTime) {
                    stats.push({
                        label: 'Swing Time',
                        value: m.totalTime.toFixed(2),
                        unit: 's',
                        range: 'Typical: 1.0-1.4s',
                        status: 'good'
                    });
                }
                
                this.basicStatsGrid.innerHTML = stats.map(stat => `
                    <div class="stat-card stat-${stat.status}">
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value">${stat.value}<span class="stat-unit">${stat.unit}</span></div>
                        <div class="stat-range">${stat.range}</div>
                    </div>
                `).join('');
            }
            
            renderAdvancedStats(m) {
                const clubConfig = this.clubConfigs[this.clubType];
                const ranges = clubConfig.idealRanges;
                
                // Rotation stats
                const rotationStats = [];
                if (m.hipTurn) {
                    const isGood = m.hipTurn >= ranges.hipTurn.min && m.hipTurn <= ranges.hipTurn.max;
                    rotationStats.push({
                        label: 'Hip Turn',
                        value: m.hipTurn,
                        unit: '',
                        range: `Ideal: ${ranges.hipTurn.label}`,
                        status: isGood ? 'good' : 'warning'
                    });
                }
                if (m.hipShoulderSep) {
                    const isGood = m.hipShoulderSep >= 35;
                    rotationStats.push({
                        label: 'Hip-Shoulder Sep',
                        value: m.hipShoulderSep,
                        unit: '',
                        range: 'Ideal: 35+',
                        status: isGood ? 'good' : 'warning'
                    });
                }
                if (m.spineTilt) {
                    rotationStats.push({
                        label: 'Spine Tilt',
                        value: m.spineTilt,
                        unit: '',
                        range: 'Typical: 3-8',
                        status: 'good'
                    });
                }
                document.getElementById('rotationStatsGrid').innerHTML = this.renderStatCards(rotationStats);
                
                // Stability stats
                const stabilityStats = [];
                if (m.headMovement !== undefined) {
                    const pct = (m.headMovement * 100).toFixed(1);
                    const isGood = m.headMovement < 0.04;
                    stabilityStats.push({
                        label: 'Head Movement',
                        value: pct,
                        unit: '%',
                        range: 'Ideal: <4%',
                        status: isGood ? 'good' : 'warning'
                    });
                }
                if (m.spineAngleMaintained !== undefined) {
                    stabilityStats.push({
                        label: 'Spine Maintained',
                        value: m.spineAngleMaintained ? 'Yes' : 'No',
                        unit: '',
                        range: '',
                        status: m.spineAngleMaintained ? 'good' : 'warning'
                    });
                }
                document.getElementById('stabilityStatsGrid').innerHTML = this.renderStatCards(stabilityStats);
                
                // Timing stats
                const timingStats = [];
                if (m.backswingTime) {
                    timingStats.push({
                        label: 'Backswing',
                        value: m.backswingTime.toFixed(2),
                        unit: 's',
                        range: '',
                        status: 'good'
                    });
                }
                if (m.downswingTime) {
                    timingStats.push({
                        label: 'Downswing',
                        value: m.downswingTime.toFixed(2),
                        unit: 's',
                        range: '',
                        status: 'good'
                    });
                }
                if (m.followthroughTime) {
                    timingStats.push({
                        label: 'Follow-through',
                        value: m.followthroughTime.toFixed(2),
                        unit: 's',
                        range: '',
                        status: 'good'
                    });
                }
                document.getElementById('timingStatsGrid').innerHTML = this.renderStatCards(timingStats);
                
                // Position stats
                const positionStats = [];
                if (m.stanceWidth) {
                    const isGood = m.stanceWidth >= 0.9 && m.stanceWidth <= 1.3;
                    positionStats.push({
                        label: 'Stance Width',
                        value: m.stanceWidth.toFixed(1),
                        unit: 'x',
                        range: 'Ideal: 1.0-1.2x shoulder',
                        status: isGood ? 'good' : 'warning'
                    });
                }
                if (m.weightTransfer !== undefined) {
                    const isGood = m.weightTransfer >= 80;
                    positionStats.push({
                        label: 'Weight Transfer',
                        value: m.weightTransfer,
                        unit: '%',
                        range: 'Ideal: 80%+',
                        status: isGood ? 'good' : 'warning'
                    });
                }
                if (m.leadArmAngle) {
                    const isGood = m.leadArmAngle >= 170;
                    positionStats.push({
                        label: 'Lead Arm',
                        value: m.leadArmAngle,
                        unit: '',
                        range: 'Ideal: 170+ (straight)',
                        status: isGood ? 'good' : 'warning'
                    });
                }
                document.getElementById('positionsStatsGrid').innerHTML = this.renderStatCards(positionStats);
            }
            
            renderStatCards(stats) {
                if (stats.length === 0) {
                    return '<div class="stat-card"><div class="stat-label">No data</div></div>';
                }
                return stats.map(stat => `
                    <div class="stat-card stat-${stat.status}">
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value">${stat.value}<span class="stat-unit">${stat.unit}</span></div>
                        ${stat.range ? `<div class="stat-range">${stat.range}</div>` : ''}
                    </div>
                `).join('');
            }
            
            // ========================================
            // AUTO-CROP FUNCTIONALITY
            // ========================================
            
            calculateCropRegion(framesData) {
                if (!framesData || framesData.length === 0) return null;
                
                let minX = 1, maxX = 0, minY = 1, maxY = 0;
                
                // Find bounding box across all frames
                framesData.forEach(frame => {
                    if (!frame.landmarks) return;
                    
                    frame.landmarks.forEach((point, idx) => {
                        // Only use body points (11-28)
                        if (idx >= 11 && idx <= 28 && point.visibility > 0.5) {
                            minX = Math.min(minX, point.x);
                            maxX = Math.max(maxX, point.x);
                            minY = Math.min(minY, point.y);
                            maxY = Math.max(maxY, point.y);
                        }
                    });
                });
                
                // Calculate body dimensions
                const bodyWidth = maxX - minX;
                const bodyHeight = maxY - minY;
                
                // Vertical padding
                minY = Math.max(0, minY - bodyHeight * 0.15); // Top padding for head/club
                maxY = Math.min(1, maxY + bodyHeight * 0.25); // Bottom padding for feet/ball
                
                // Horizontal padding - much more on ball side for DTL
                if (this.cameraAngle === 'dtl') {
                    // DTL view needs significant padding on ball side
                    const ballSidePadding = bodyWidth * 1.5;  // 150% extra on ball side
                    const backSidePadding = bodyWidth * 0.2;  // 20% on back side
                    
                    if (this.golferHandedness === 'right') {
                        // Right-handed: ball is to the RIGHT in DTL
                        minX = Math.max(0, minX - backSidePadding);
                        maxX = Math.min(1, maxX + ballSidePadding);
                    } else {
                        // Left-handed: ball is to the LEFT in DTL
                        minX = Math.max(0, minX - ballSidePadding);
                        maxX = Math.min(1, maxX + backSidePadding);
                    }
                } else {
                    // Face-on view - more balanced
                    minX = Math.max(0, minX - bodyWidth * 0.25);
                    maxX = Math.min(1, maxX + bodyWidth * 0.25);
                }
                
                return { minX, maxX, minY, maxY };
            }
            
            drawCroppedFrame(ctx, video, landmarks, canvasWidth, canvasHeight, cropRegion) {
                const vw = video.videoWidth;
                const vh = video.videoHeight;
                
                // Clear canvas first
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                if (cropRegion && this.autoCropEnabled) {
                    // Calculate source rectangle
                    const sx = cropRegion.minX * vw;
                    const sy = cropRegion.minY * vh;
                    const sw = (cropRegion.maxX - cropRegion.minX) * vw;
                    const sh = (cropRegion.maxY - cropRegion.minY) * vh;
                    
                    // Calculate destination maintaining aspect ratio
                    const srcAspect = sw / sh;
                    const dstAspect = canvasWidth / canvasHeight;
                    
                    let dw, dh, dx, dy;
                    
                    if (srcAspect > dstAspect) {
                        // Source is wider - fit to width
                        dw = canvasWidth;
                        dh = canvasWidth / srcAspect;
                        dx = 0;
                        dy = (canvasHeight - dh) / 2;
                    } else {
                        // Source is taller - fit to height
                        dh = canvasHeight;
                        dw = canvasHeight * srcAspect;
                        dx = (canvasWidth - dw) / 2;
                        dy = 0;
                    }
                    
                    // Store the actual draw region for skeleton alignment
                    this.lastDrawRegion = { dx, dy, dw, dh, sx, sy, sw, sh };
                    
                    // Draw cropped region with correct aspect ratio
                    ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
                    
                    // Adjust landmarks for crop
                    if (landmarks) {
                        this.drawSkeletonCropped(ctx, landmarks, canvasWidth, canvasHeight, cropRegion, this.lastDrawRegion);
                    }
                } else {
                    // No crop - fit full video maintaining aspect ratio
                    const srcAspect = vw / vh;
                    const dstAspect = canvasWidth / canvasHeight;
                    
                    let dw, dh, dx, dy;
                    
                    if (srcAspect > dstAspect) {
                        dw = canvasWidth;
                        dh = canvasWidth / srcAspect;
                        dx = 0;
                        dy = (canvasHeight - dh) / 2;
                    } else {
                        dh = canvasHeight;
                        dw = canvasHeight * srcAspect;
                        dx = (canvasWidth - dw) / 2;
                        dy = 0;
                    }
                    
                    this.lastDrawRegion = { dx, dy, dw, dh, sx: 0, sy: 0, sw: vw, sh: vh };
                    
                    ctx.drawImage(video, 0, 0, vw, vh, dx, dy, dw, dh);
                    if (landmarks) {
                        this.drawSkeleton(ctx, landmarks, canvasWidth, canvasHeight, this.lastDrawRegion);
                    }
                }
            }
            
            drawSkeletonCropped(ctx, landmarks, width, height, cropRegion, drawRegion) {
                const connections = [
                    [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
                    [11, 23], [12, 24], [23, 24], [23, 25], [25, 27], [24, 26], [26, 28]
                ];
                
                const cropWidth = cropRegion.maxX - cropRegion.minX;
                const cropHeight = cropRegion.maxY - cropRegion.minY;
                
                // Transform function - accounts for aspect-ratio-preserved drawing
                const transform = (point) => {
                    // First normalize within crop region (0-1)
                    const normX = (point.x - cropRegion.minX) / cropWidth;
                    const normY = (point.y - cropRegion.minY) / cropHeight;
                    
                    // Then map to actual draw region
                    return {
                        x: drawRegion.dx + normX * drawRegion.dw,
                        y: drawRegion.dy + normY * drawRegion.dh
                    };
                };
                
                ctx.strokeStyle = 'rgba(74, 222, 128, 0.8)';
                ctx.lineWidth = 3;
                
                connections.forEach(([i, j]) => {
                    const p1 = landmarks[i];
                    const p2 = landmarks[j];
                    
                    if (p1.visibility > 0.5 && p2.visibility > 0.5) {
                        const t1 = transform(p1);
                        const t2 = transform(p2);
                        ctx.beginPath();
                        ctx.moveTo(t1.x, t1.y);
                        ctx.lineTo(t2.x, t2.y);
                        ctx.stroke();
                    }
                });
                
                ctx.fillStyle = 'rgba(163, 230, 53, 1)';
                landmarks.forEach((point, idx) => {
                    if (point.visibility > 0.5 && idx >= 11 && idx <= 28) {
                        const t = transform(point);
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
            
            // ========================================
            // PRO COMPARISON MODE
            // ========================================
            
            async runProComparison() {
                if (this.isProcessing) return;
                this.isProcessing = true;
                
                this.compareBtn.disabled = true;
                this.compareBtn.innerHTML = '<span class="spinner"></span>Analyzing...';
                this.compareProgressContainer.classList.add('visible');
                
                try {
                    // Analyze user's swing with timeout
                    this.compareProgressText.textContent = 'Analyzing your swing...';
                    
                    const analysisPromise = this.analyzeSwingForComparison(this.userSwing);
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Analysis timeout')), 120000) // 2 min timeout
                    );
                    
                    await Promise.race([analysisPromise, timeoutPromise]);
                    this.compareProgressFill.style.width = '100%';
                    
                    // Calculate measurements
                    this.userSwing.measurements = this.calculateMeasurementsForSwing(this.userSwing.keyFrames);
                    
                    // Update pro name display
                    const pro = this.proData[this.selectedPro];
                    this.proNameDisplay.textContent = pro.name;
                    
                    // Show results
                    this.compareProgressContainer.classList.remove('visible');
                    this.comparisonResults.classList.add('visible');
                    
                    // Render initial comparison
                    this.selectComparePhase('address');
                    this.renderProComparisonMetrics();
                    this.renderProTips();
                    
                } catch (error) {
                    console.error('Comparison error:', error);
                    alert('Analysis took too long or encountered an error. Try a shorter video clip.');
                    this.compareProgressContainer.classList.remove('visible');
                    this.compareBtn.disabled = false;
                    this.compareBtn.innerHTML = 'Compare Swings';
                }
                
                this.isProcessing = false;
            }
            
            async analyzeSwingForComparison(swingData) {
                return new Promise(async (resolve) => {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(swingData.file);
                    video.muted = true;
                    video.playsInline = true;
                    video.preload = 'auto';
                    
                    video.onloadedmetadata = async () => {
                        // Wait for video to be fully loaded
                        await new Promise(r => {
                            if (video.readyState >= 3) r();
                            else video.oncanplay = r;
                        });
                        
                        swingData.framesData = [];
                        swingData.videoWidth = video.videoWidth;
                        swingData.videoHeight = video.videoHeight;
                        
                        // PHASE 1: Quick pre-scan to detect swing boundaries
                        this.compareProgressText.textContent = 'Detecting swing...';
                        const swingBounds = await this.detectSwingBoundariesForVideo(video);
                        
                        // PHASE 2: Only analyze frames within swing boundaries
                        const startTime = swingBounds.start;
                        const endTime = swingBounds.end;
                        const swingDuration = endTime - startTime;
                        
                        const fps = 30;
                        const totalFrames = Math.floor(swingDuration * fps);
                        const frameInterval = swingDuration / totalFrames;
                        
                        this.compareProgressText.textContent = `Analyzing ${totalFrames} frames...`;
                        console.log(`Starting analysis: ${totalFrames} frames from ${startTime.toFixed(2)}s to ${endTime.toFixed(2)}s`);
                        
                        // Helper function to seek with timeout
                        const seekTo = (time) => {
                            return new Promise((resolve) => {
                                const onSeeked = () => {
                                    video.removeEventListener('seeked', onSeeked);
                                    resolve();
                                };
                                video.addEventListener('seeked', onSeeked);
                                video.currentTime = time;
                                setTimeout(resolve, 200);
                            });
                        };
                        
                        // Set up temporary results collector
                        let frameResolve = null;
                        const originalCallback = this.onPoseResults.bind(this);
                        
                        this.pose.onResults((results) => {
                            if (results.poseLandmarks && frameResolve) {
                                swingData.framesData.push({
                                    frameNumber: swingData.framesData.length,
                                    landmarks: results.poseLandmarks,
                                    timestamp: video.currentTime
                                });
                            }
                            if (frameResolve) {
                                frameResolve();
                                frameResolve = null;
                            }
                        });
                        
                        for (let i = 0; i < totalFrames; i++) {
                            await seekTo(startTime + (i * frameInterval));
                            
                            const progress = 30 + ((i + 1) / totalFrames) * 70;
                            this.compareProgressFill.style.width = `${progress}%`;
                            
                            if (i % 10 === 0) {
                                this.compareProgressText.textContent = `Analyzing frame ${i + 1} of ${totalFrames}...`;
                            }
                            
                            await new Promise(r => {
                                frameResolve = r;
                                this.pose.send({ image: video });
                            });
                        }
                        
                        console.log(`Analysis complete: ${swingData.framesData.length} frames captured`);
                        
                        // Restore original callback
                        this.pose.onResults((results) => this.onPoseResults(results));
                        
                        // Detect key frames
                        swingData.keyFrames = this.detectKeyFramesForData(swingData.framesData);
                        swingData.cropRegion = this.calculateCropRegion(swingData.framesData);
                        swingData.video = video;
                        
                        resolve();
                    };
                    
                    video.load();
                });
            }
            
            async detectSwingBoundariesForVideo(video) {
                // Quick scan at ~10fps to find swing start/end based on motion
                const scanFps = 10;
                const totalScanFrames = Math.floor(video.duration * scanFps);
                const frameInterval = video.duration / totalScanFrames;
                
                const motionData = [];
                let prevImageData = null;
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 160;
                tempCanvas.height = 120;
                const tempCtx = tempCanvas.getContext('2d');
                
                for (let i = 0; i < totalScanFrames; i++) {
                    video.currentTime = i * frameInterval;
                    await new Promise(resolve => { video.onseeked = resolve; });
                    
                    tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    
                    if (prevImageData) {
                        let motion = 0;
                        for (let j = 0; j < imageData.data.length; j += 4) {
                            motion += Math.abs(imageData.data[j] - prevImageData.data[j]);
                        }
                        motionData.push({ time: i * frameInterval, motion: motion });
                    }
                    
                    prevImageData = imageData;
                    
                    const progress = (i / totalScanFrames) * 30;
                    this.compareProgressFill.style.width = `${progress}%`;
                }
                
                const maxMotion = Math.max(...motionData.map(d => d.motion));
                const motionThreshold = maxMotion * 0.15;
                
                let startTime = 0;
                for (let i = 0; i < motionData.length; i++) {
                    if (motionData[i].motion > motionThreshold) {
                        startTime = Math.max(0, motionData[Math.max(0, i - 3)].time);
                        break;
                    }
                }
                
                let endTime = video.duration;
                let foundPeak = false;
                for (let i = 0; i < motionData.length; i++) {
                    if (motionData[i].motion > maxMotion * 0.5) {
                        foundPeak = true;
                    }
                    if (foundPeak && motionData[i].motion < motionThreshold) {
                        endTime = Math.min(video.duration, motionData[Math.min(motionData.length - 1, i + 5)].time);
                        break;
                    }
                }
                
                if (endTime - startTime < 1.0) {
                    startTime = 0;
                    endTime = video.duration;
                }
                
                return { start: startTime, end: endTime };
            }
            
            detectKeyFramesForData(frames) {
                if (frames.length < 10) return {};
                
                const wristSpeeds = frames.map((frame, i) => {
                    if (i < 2 || i >= frames.length - 2) return 0;
                    const prev = frames[i - 2].landmarks;
                    const next = frames[i + 2].landmarks;
                    const prevWrist = this.getWristPosition(prev);
                    const nextWrist = this.getWristPosition(next);
                    return Math.sqrt(Math.pow(nextWrist.x - prevWrist.x, 2) + Math.pow(nextWrist.y - prevWrist.y, 2));
                });
                
                let addressIdx = 0;
                for (let i = 0; i < Math.min(frames.length / 3, 30); i++) {
                    if (wristSpeeds[i] < 0.01) addressIdx = i;
                    else if (wristSpeeds[i] > 0.02) break;
                }
                
                // Get address wrist position for reference
                const addressWrist = this.getWristPosition(frames[addressIdx].landmarks);
                
                let topIdx = addressIdx, minY = 1;
                for (let i = addressIdx + 5; i < frames.length * 0.6; i++) {
                    const wrist = this.getWristPosition(frames[i].landmarks);
                    if (wrist.y < minY && wristSpeeds[i] < wristSpeeds[i - 3]) {
                        minY = wrist.y;
                        topIdx = i;
                    }
                }
                
                // Find impact - look for MAXIMUM arm extension (fully extended to the ball)
                let impactIdx = topIdx;
                let maxExtension = 0;
                
                for (let i = topIdx + 5; i < frames.length - 5; i++) {
                    const landmarks = frames[i].landmarks;
                    const wrist = this.getWristPosition(landmarks);
                    
                    // Only consider frames where wrists are in the lower half
                    if (wrist.y < 0.45) continue;
                    
                    const leftShoulder = landmarks[this.KEYPOINTS.LEFT_SHOULDER];
                    const leftWrist = landmarks[this.KEYPOINTS.LEFT_WRIST];
                    const rightShoulder = landmarks[this.KEYPOINTS.RIGHT_SHOULDER];
                    const rightWrist = landmarks[this.KEYPOINTS.RIGHT_WRIST];
                    
                    // Calculate total arm extension
                    const leftArmExt = Math.sqrt(
                        Math.pow(leftWrist.x - leftShoulder.x, 2) + 
                        Math.pow(leftWrist.y - leftShoulder.y, 2)
                    );
                    const rightArmExt = Math.sqrt(
                        Math.pow(rightWrist.x - rightShoulder.x, 2) + 
                        Math.pow(rightWrist.y - rightShoulder.y, 2)
                    );
                    
                    const totalExtension = leftArmExt + rightArmExt;
                    
                    if (totalExtension > maxExtension) {
                        maxExtension = totalExtension;
                        impactIdx = i;
                    }
                }
                
                // Fallback - find lowest wrist position
                if (impactIdx === topIdx) {
                    let lowestY = 0;
                    for (let i = topIdx + 5; i < frames.length - 5; i++) {
                        const wrist = this.getWristPosition(frames[i].landmarks);
                        if (wrist.y > lowestY) {
                            lowestY = wrist.y;
                            impactIdx = i;
                        }
                    }
                }
                
                let finishIdx = frames.length - 1;
                for (let i = impactIdx + 5; i < frames.length; i++) {
                    const wrist = this.getWristPosition(frames[i].landmarks);
                    if (wristSpeeds[i] < 0.01 && wrist.y < 0.4) {
                        finishIdx = i;
                        break;
                    }
                }
                
                return {
                    address: frames[addressIdx],
                    top: frames[topIdx],
                    impact: frames[impactIdx],
                    finish: frames[finishIdx]
                };
            }
            
            calculateMeasurementsForSwing(keyFrames) {
                const measurements = {};
                if (keyFrames.address && keyFrames.top) {
                    const addressShoulderTilt = this.calculateShoulderTilt(keyFrames.address.landmarks);
                    const topShoulderTilt = this.calculateShoulderTilt(keyFrames.top.landmarks);
                    measurements.shoulderTurn = Math.abs(topShoulderTilt - addressShoulderTilt).toFixed(0);
                    
                    const addressHipTilt = this.calculateHipTilt(keyFrames.address.landmarks);
                    const topHipTilt = this.calculateHipTilt(keyFrames.top.landmarks);
                    measurements.hipTurn = Math.abs(topHipTilt - addressHipTilt).toFixed(0);
                    
                    measurements.xFactor = Math.abs(measurements.shoulderTurn - measurements.hipTurn).toFixed(0);
                }
                if (keyFrames.address) {
                    measurements.spineTilt = this.calculateSpineTilt(keyFrames.address.landmarks).toFixed(0);
                }
                return measurements;
            }
            
            selectComparePhase(phase) {
                this.currentComparePhase = phase;
                
                // Update button states
                this.phaseSelector.querySelectorAll('.phase-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.phase === phase);
                });
                
                this.updateProComparisonView();
                this.renderProTips();
            }
            
            updateProComparisonView() {
                const phase = this.currentComparePhase;
                const userFrame = this.userSwing.keyFrames[phase];
                
                // Render user's frame
                this.renderUserFrame(userFrame);
                
                // Render pro reference skeleton
                this.renderProReference(phase);
            }
            
            renderUserFrame(frame) {
                const canvas = document.getElementById('compareCanvasUser');
                const ctx = canvas.getContext('2d');
                
                if (!frame || !this.userSwing.video) return;
                
                canvas.width = 300;
                canvas.height = 400;
                
                this.userSwing.video.currentTime = frame.timestamp;
                
                // Wait for seek to complete before drawing
                this.userSwing.video.onseeked = () => {
                    this.drawCroppedFrame(ctx, this.userSwing.video, frame.landmarks, 
                        canvas.width, canvas.height, this.userSwing.cropRegion);
                };
            }
            
            renderProReference(phase) {
                const canvas = document.getElementById('compareCanvasPro');
                const ctx = canvas.getContext('2d');
                const pro = this.proData[this.selectedPro];
                
                canvas.width = 300;
                canvas.height = 400;
                
                // Draw background
                ctx.fillStyle = '#141f14';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Get the camera angle
                const angle = this.compareAngle || 'faceon';
                
                // Check if we have a direct image URL
                const imageUrl = pro.images?.[angle]?.[phase];
                
                // Check if we have a video URL we can extract a thumbnail from
                const videoUrl = pro.videos?.[this.clubType]?.[angle];
                
                if (imageUrl) {
                    // Use direct image
                    this.loadProImage(ctx, canvas, imageUrl, pro, phase, angle);
                } else if (videoUrl && videoUrl.includes('youtube')) {
                    // Try to use YouTube thumbnail
                    let videoId = null;
                    if (videoUrl.includes('youtube.com/watch')) {
                        videoId = new URL(videoUrl).searchParams.get('v');
                    } else if (videoUrl.includes('youtube.com/shorts')) {
                        videoId = videoUrl.split('/shorts/')[1].split('?')[0];
                    } else if (videoUrl.includes('youtu.be')) {
                        videoId = videoUrl.split('youtu.be/')[1].split('?')[0];
                    }
                    
                    if (videoId) {
                        // Use YouTube's high quality thumbnail
                        const thumbUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
                        this.loadProImage(ctx, canvas, thumbUrl, pro, phase, angle, true);
                    } else {
                        // Fall back to skeleton
                        this.renderProSkeleton(ctx, phase, canvas.width, canvas.height, pro);
                    }
                } else {
                    // No image or video available - use skeleton
                    this.renderProSkeleton(ctx, phase, canvas.width, canvas.height, pro);
                }
            }
            
            loadProImage(ctx, canvas, imageUrl, pro, phase, angle, isVideoThumb = false) {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    // Calculate aspect-ratio-preserving dimensions
                    const imgAspect = img.width / img.height;
                    const canvasAspect = canvas.width / canvas.height;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (imgAspect > canvasAspect) {
                        // Image is wider - fit to width
                        drawWidth = canvas.width;
                        drawHeight = canvas.width / imgAspect;
                        drawX = 0;
                        drawY = (canvas.height - drawHeight) / 2;
                    } else {
                        // Image is taller - fit to height
                        drawHeight = canvas.height;
                        drawWidth = canvas.height * imgAspect;
                        drawX = (canvas.width - drawWidth) / 2;
                        drawY = 0;
                    }
                    
                    // Clear and redraw background
                    ctx.fillStyle = '#141f14';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw the image
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    
                    // Add gradient overlay at bottom for text
                    const gradient = ctx.createLinearGradient(0, canvas.height - 80, 0, canvas.height);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    
                    // Add pro name and phase label
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.font = 'bold 14px "DM Sans", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(pro.name, canvas.width / 2, canvas.height - 28);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = '12px "DM Sans", sans-serif';
                    const phaseLabel = phase.charAt(0).toUpperCase() + phase.slice(1);
                    const angleLabel = angle === 'faceon' ? 'Face-On' : 'DTL';
                    const sourceLabel = isVideoThumb ? ' (Video)' : '';
                    ctx.fillText(`${phaseLabel}  ${angleLabel}${sourceLabel}`, canvas.width / 2, canvas.height - 10);
                };
                
                img.onerror = () => {
                    // If image fails to load, fall back to skeleton
                    console.log('Pro image failed to load, using skeleton');
                    this.renderProSkeleton(ctx, phase, canvas.width, canvas.height, pro);
                };
                
                // Show loading state
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '14px "DM Sans", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Loading reference...', canvas.width / 2, canvas.height / 2);
                
                img.src = imageUrl;
            }
            
            renderProSkeleton(ctx, phase, width, height, pro) {
                // Clear canvas
                ctx.fillStyle = '#141f14';
                ctx.fillRect(0, 0, width, height);
                
                // Get pro's ideal skeleton for this phase and angle
                const angle = this.compareAngle || 'faceon';
                const proSkeleton = this.getProSkeleton(phase, angle);
                
                // Draw reference skeleton
                this.drawProSkeleton(ctx, proSkeleton, width, height);
                
                // Add gradient overlay at bottom
                const gradient = ctx.createLinearGradient(0, height - 80, 0, height);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, height - 80, width, 80);
                
                ctx.fillStyle = pro.color || 'rgba(96, 165, 250, 0.9)';
                ctx.font = 'bold 14px "DM Sans", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(pro.name, width / 2, height - 28);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '12px "DM Sans", sans-serif';
                const phaseLabel = phase.charAt(0).toUpperCase() + phase.slice(1);
                const angleLabel = angle === 'faceon' ? 'Face-On' : 'DTL';
                ctx.fillText(`${phaseLabel}  ${angleLabel} (Reference)`, width / 2, height - 10);
            }
            
            getProSkeleton(phase, angle = 'faceon') {
                // Idealized skeleton positions for each phase and angle
                const skeletons = {
                    faceon: {
                        address: {
                            nose: { x: 0.5, y: 0.15 },
                            leftShoulder: { x: 0.58, y: 0.28 },
                            rightShoulder: { x: 0.42, y: 0.30 },
                            leftElbow: { x: 0.65, y: 0.40 },
                            rightElbow: { x: 0.35, y: 0.42 },
                            leftWrist: { x: 0.52, y: 0.52 },
                            rightWrist: { x: 0.48, y: 0.52 },
                            leftHip: { x: 0.55, y: 0.52 },
                            rightHip: { x: 0.45, y: 0.52 },
                            leftKnee: { x: 0.58, y: 0.72 },
                            rightKnee: { x: 0.42, y: 0.72 },
                            leftAnkle: { x: 0.60, y: 0.92 },
                            rightAnkle: { x: 0.40, y: 0.92 }
                        },
                        top: {
                            nose: { x: 0.48, y: 0.15 },
                            leftShoulder: { x: 0.45, y: 0.26 },
                            rightShoulder: { x: 0.55, y: 0.32 },
                            leftElbow: { x: 0.38, y: 0.18 },
                            rightElbow: { x: 0.62, y: 0.28 },
                            leftWrist: { x: 0.52, y: 0.12 },
                            rightWrist: { x: 0.58, y: 0.15 },
                            leftHip: { x: 0.52, y: 0.52 },
                            rightHip: { x: 0.46, y: 0.53 },
                            leftKnee: { x: 0.56, y: 0.72 },
                            rightKnee: { x: 0.40, y: 0.73 },
                            leftAnkle: { x: 0.60, y: 0.92 },
                            rightAnkle: { x: 0.40, y: 0.92 }
                        },
                        impact: {
                            nose: { x: 0.48, y: 0.16 },
                            leftShoulder: { x: 0.55, y: 0.28 },
                            rightShoulder: { x: 0.42, y: 0.32 },
                            leftElbow: { x: 0.60, y: 0.40 },
                            rightElbow: { x: 0.38, y: 0.44 },
                            leftWrist: { x: 0.50, y: 0.52 },
                            rightWrist: { x: 0.45, y: 0.54 },
                            leftHip: { x: 0.58, y: 0.50 },
                            rightHip: { x: 0.48, y: 0.52 },
                            leftKnee: { x: 0.62, y: 0.70 },
                            rightKnee: { x: 0.42, y: 0.74 },
                            leftAnkle: { x: 0.60, y: 0.92 },
                            rightAnkle: { x: 0.40, y: 0.92 }
                        },
                        finish: {
                            nose: { x: 0.52, y: 0.15 },
                            leftShoulder: { x: 0.58, y: 0.26 },
                            rightShoulder: { x: 0.48, y: 0.30 },
                            leftElbow: { x: 0.52, y: 0.18 },
                            rightElbow: { x: 0.58, y: 0.22 },
                            leftWrist: { x: 0.45, y: 0.14 },
                            rightWrist: { x: 0.50, y: 0.16 },
                            leftHip: { x: 0.58, y: 0.50 },
                            rightHip: { x: 0.52, y: 0.52 },
                            leftKnee: { x: 0.58, y: 0.70 },
                            rightKnee: { x: 0.55, y: 0.75 },
                            leftAnkle: { x: 0.58, y: 0.92 },
                            rightAnkle: { x: 0.52, y: 0.90 }
                        }
                    },
                    dtl: {
                        address: {
                            nose: { x: 0.45, y: 0.15 },
                            leftShoulder: { x: 0.48, y: 0.28 },
                            rightShoulder: { x: 0.52, y: 0.28 },
                            leftElbow: { x: 0.42, y: 0.40 },
                            rightElbow: { x: 0.58, y: 0.40 },
                            leftWrist: { x: 0.38, y: 0.52 },
                            rightWrist: { x: 0.62, y: 0.52 },
                            leftHip: { x: 0.48, y: 0.52 },
                            rightHip: { x: 0.52, y: 0.52 },
                            leftKnee: { x: 0.46, y: 0.72 },
                            rightKnee: { x: 0.54, y: 0.72 },
                            leftAnkle: { x: 0.44, y: 0.92 },
                            rightAnkle: { x: 0.56, y: 0.92 }
                        },
                        top: {
                            nose: { x: 0.42, y: 0.15 },
                            leftShoulder: { x: 0.40, y: 0.26 },
                            rightShoulder: { x: 0.55, y: 0.30 },
                            leftElbow: { x: 0.32, y: 0.20 },
                            rightElbow: { x: 0.48, y: 0.18 },
                            leftWrist: { x: 0.28, y: 0.12 },
                            rightWrist: { x: 0.38, y: 0.10 },
                            leftHip: { x: 0.45, y: 0.52 },
                            rightHip: { x: 0.55, y: 0.53 },
                            leftKnee: { x: 0.44, y: 0.72 },
                            rightKnee: { x: 0.56, y: 0.72 },
                            leftAnkle: { x: 0.42, y: 0.92 },
                            rightAnkle: { x: 0.58, y: 0.92 }
                        },
                        impact: {
                            nose: { x: 0.48, y: 0.16 },
                            leftShoulder: { x: 0.50, y: 0.28 },
                            rightShoulder: { x: 0.52, y: 0.30 },
                            leftElbow: { x: 0.55, y: 0.40 },
                            rightElbow: { x: 0.48, y: 0.42 },
                            leftWrist: { x: 0.60, y: 0.52 },
                            rightWrist: { x: 0.55, y: 0.54 },
                            leftHip: { x: 0.52, y: 0.50 },
                            rightHip: { x: 0.50, y: 0.52 },
                            leftKnee: { x: 0.54, y: 0.70 },
                            rightKnee: { x: 0.50, y: 0.72 },
                            leftAnkle: { x: 0.48, y: 0.92 },
                            rightAnkle: { x: 0.52, y: 0.92 }
                        },
                        finish: {
                            nose: { x: 0.55, y: 0.15 },
                            leftShoulder: { x: 0.58, y: 0.26 },
                            rightShoulder: { x: 0.50, y: 0.28 },
                            leftElbow: { x: 0.65, y: 0.18 },
                            rightElbow: { x: 0.55, y: 0.20 },
                            leftWrist: { x: 0.60, y: 0.12 },
                            rightWrist: { x: 0.55, y: 0.14 },
                            leftHip: { x: 0.56, y: 0.50 },
                            rightHip: { x: 0.50, y: 0.52 },
                            leftKnee: { x: 0.54, y: 0.70 },
                            rightKnee: { x: 0.52, y: 0.74 },
                            leftAnkle: { x: 0.52, y: 0.92 },
                            rightAnkle: { x: 0.50, y: 0.90 }
                        }
                    }
                };
                
                return skeletons[angle]?.[phase] || skeletons.faceon[phase];
            }
            
            drawProSkeleton(ctx, skeleton, width, height) {
                const points = {
                    11: skeleton.leftShoulder,
                    12: skeleton.rightShoulder,
                    13: skeleton.leftElbow,
                    14: skeleton.rightElbow,
                    15: skeleton.leftWrist,
                    16: skeleton.rightWrist,
                    23: skeleton.leftHip,
                    24: skeleton.rightHip,
                    25: skeleton.leftKnee,
                    26: skeleton.rightKnee,
                    27: skeleton.leftAnkle,
                    28: skeleton.rightAnkle
                };
                
                const connections = [
                    [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
                    [11, 23], [12, 24], [23, 24], [23, 25], [25, 27], [24, 26], [26, 28]
                ];
                
                // Draw connections
                ctx.strokeStyle = 'rgba(96, 165, 250, 0.8)';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                connections.forEach(([i, j]) => {
                    const p1 = points[i];
                    const p2 = points[j];
                    if (p1 && p2) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x * width, p1.y * height);
                        ctx.lineTo(p2.x * width, p2.y * height);
                        ctx.stroke();
                    }
                });
                
                // Draw points
                ctx.fillStyle = 'rgba(96, 165, 250, 1)';
                Object.values(points).forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x * width, point.y * height, 6, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw head
                if (skeleton.nose) {
                    ctx.beginPath();
                    ctx.arc(skeleton.nose.x * width, skeleton.nose.y * height, 15, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(96, 165, 250, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
            
            renderProComparisonMetrics() {
                const container = document.getElementById('comparisonMetrics');
                const userM = this.userSwing.measurements;
                const pro = this.proData[this.selectedPro];
                
                // Get club-specific pro metrics
                const proM = pro[this.clubType]?.[this.compareAngle] || pro.driver?.faceon || {};
                
                const metrics = [
                    { 
                        name: 'Shoulder Turn', 
                        user: userM.shoulderTurn, 
                        pro: proM.shoulderTurn, 
                        unit: '',
                        tolerance: 10
                    },
                    { 
                        name: 'Hip Turn', 
                        user: userM.hipTurn, 
                        pro: proM.hipTurn, 
                        unit: '',
                        tolerance: 8
                    },
                    { 
                        name: 'X-Factor', 
                        user: userM.xFactor, 
                        pro: proM.xFactor, 
                        unit: '',
                        tolerance: 10
                    },
                    { 
                        name: 'Spine Tilt', 
                        user: userM.spineTilt, 
                        pro: proM.spineTilt, 
                        unit: '',
                        tolerance: 5
                    }
                ];
                
                // Add tempo if available for this pro/club
                if (proM.tempo && userM.tempoRatio) {
                    metrics.push({
                        name: 'Tempo',
                        user: userM.tempoRatio?.toFixed(1),
                        pro: proM.tempo,
                        unit: ':1',
                        tolerance: 0.5
                    });
                }
                
                container.innerHTML = metrics.map(m => {
                    if (!m.pro) return ''; // Skip if no pro data
                    
                    const userVal = typeof m.user === 'string' ? parseFloat(m.user) : m.user;
                    const diff = userVal && m.pro ? Math.abs(userVal - m.pro) : null;
                    const isGood = diff !== null && diff <= m.tolerance;
                    const diffClass = isGood ? 'good' : 'needs-work';
                    const diffText = diff !== null ? (isGood ? ' Close' : `${diff.toFixed(1)} off`) : '';
                    
                    return `
                        <div class="metric-row">
                            <span class="metric-name">${m.name}</span>
                            <div class="metric-values">
                                <span class="metric-value swing-a">${m.user || '-'}${m.user ? m.unit : ''}</span>
                                <span class="metric-value swing-b">${m.pro}${m.unit}</span>
                                ${diff !== null ? `<span class="diff ${diffClass}">${diffText}</span>` : ''}
                            </div>
                        </div>
                    `;
                }).filter(Boolean).join('');
            }
            
            renderProTips() {
                const container = document.getElementById('proTipsContainer');
                const pro = this.proData[this.selectedPro];
                const phase = this.currentComparePhase;
                
                // Get club-specific tips and traits
                const clubTips = pro.tips[this.clubType] || pro.tips.driver || pro.tips;
                const tip = clubTips[phase] || `Focus on ${phase} position fundamentals.`;
                
                const clubData = pro[this.clubType]?.[this.compareAngle] || pro.driver?.faceon || {};
                const traits = clubData.traits || [];
                
                let html = `
                    <div class="pro-tip-item">
                        <div class="pro-tip-title">${pro.name}'s ${this.clubType.charAt(0).toUpperCase() + this.clubType.slice(1)} - ${phase.charAt(0).toUpperCase() + phase.slice(1)}</div>
                        <div class="pro-tip-text">${tip}</div>
                    </div>
                `;
                
                // Add key traits
                if (traits.length > 0) {
                    html += `
                        <div class="pro-tip-item">
                            <div class="pro-tip-title">Key Traits to Emulate</div>
                            <div class="pro-tip-text">
                                ${traits.map(t => ` ${t}`).join('<br>')}
                            </div>
                        </div>
                    `;
                }
                
                // Add pro video link if available
                const videoUrl = pro.videos?.[this.clubType]?.[this.compareAngle];
                if (videoUrl) {
                    html += `
                        <div class="pro-tip-item">
                            <div class="pro-tip-title"> Watch the Pro</div>
                            <div class="pro-tip-text">
                                <a href="${videoUrl}" target="_blank" style="color: var(--accent-blue);">
                                    Watch ${pro.name}'s ${this.clubType} swing (${this.compareAngle === 'faceon' ? 'Face-On' : 'DTL'})
                                </a>
                            </div>
                        </div>
                    `;
                }
                
                // Add personalized feedback based on comparison
                const userM = this.userSwing.measurements;
                const proM = clubData;
                const feedback = this.generatePersonalizedFeedback(userM, proM);
                
                if (feedback.length > 0) {
                    html += `
                        <div class="pro-tip-item">
                            <div class="pro-tip-title">Your Focus Areas</div>
                            <div class="pro-tip-text">
                                ${feedback.map(f => ` ${f}`).join('<br>')}
                            </div>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }
            
            generatePersonalizedFeedback(userM, proM) {
                const feedback = [];
                
                if (userM.shoulderTurn && Math.abs(parseInt(userM.shoulderTurn) - proM.shoulderTurn) > 10) {
                    if (parseInt(userM.shoulderTurn) < proM.shoulderTurn) {
                        feedback.push('Work on increasing your shoulder turn for more power');
                    } else {
                        feedback.push('Your shoulder turn is larger - focus on controlling it');
                    }
                }
                
                if (userM.hipTurn && Math.abs(parseInt(userM.hipTurn) - proM.hipTurn) > 8) {
                    if (parseInt(userM.hipTurn) > proM.hipTurn) {
                        feedback.push('Try restricting your hip turn more to create better coil');
                    } else {
                        feedback.push('You might benefit from a bit more hip freedom');
                    }
                }
                
                if (userM.xFactor && Math.abs(parseInt(userM.xFactor) - proM.xFactor) > 10) {
                    if (parseInt(userM.xFactor) < proM.xFactor) {
                        feedback.push('Focus on creating more separation between shoulders and hips');
                    }
                }
                
                if (feedback.length === 0) {
                    feedback.push('Your positions are tracking well with the pro reference!');
                    feedback.push('Keep practicing to groove these positions');
                }
                
                return feedback;
            }
            
            resetComparison() {
                this.userSwing = { file: null, framesData: [], keyFrames: {}, measurements: {} };
                
                this.compareUploadArea.style.display = 'block';
                this.userVideoLoaded.style.display = 'none';
                this.compareBtn.disabled = true;
                this.compareBtn.innerHTML = 'Compare to Pro';
                this.comparisonResults.classList.remove('visible');
                this.compareVideoInput.value = '';
            }
            
            resetToUpload() {
                this.videoContainer.classList.remove('visible');
                this.videoControls.style.display = 'none';
                this.uploadSection.style.display = 'block';
                this.videoInput.value = '';
                this.framesData = [];
            }
            
            fullReset() {
                // Stop replay if playing
                this.stopReplay();
                
                this.resultsSection.classList.remove('visible');
                this.uploadSection.style.display = 'block';
                this.videoContainer.classList.remove('visible');
                this.videoControls.style.display = 'none';
                this.analyzeBtn.disabled = false;
                this.analyzeBtn.innerHTML = 'Analyze Swing';
                this.videoInput.value = '';
                this.framesData = [];
                this.keyFrames = {};
                this.replayFrameIndex = 0;
            }
        }
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            new GolfSwingAnalyzer();
        });
    </script>
</body>
</html>
